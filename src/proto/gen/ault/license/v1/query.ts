// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/license/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { License, LicenseStatus, licenseStatusFromJSON, licenseStatusToJSON, Params } from "./license";

export const protobufPackage = "ault.license.v1";

/** QueryLicenseRequest is the request for the License RPC method */
export interface QueryLicenseRequest {
  /** id is the unique identifier of the license */
  id: bigint;
}

/** QueryLicenseResponse is the response for the License RPC method */
export interface QueryLicenseResponse {
  /** license is the queried license */
  license: License | undefined;
}

/** QueryLicensesRequest is the request for the Licenses RPC method */
export interface QueryLicensesRequest {
  /** status filters licenses by status (optional) */
  status: LicenseStatus;
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryLicensesResponse is the response for the Licenses RPC method */
export interface QueryLicensesResponse {
  /** licenses is the list of licenses */
  licenses: License[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryLicensesByOwnerRequest is the request for the LicensesByOwner RPC method */
export interface QueryLicensesByOwnerRequest {
  /** owner is the address to query licenses for */
  owner: string;
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/**
 * QueryLicensesByOwnerResponse is the response for the LicensesByOwner RPC
 * method
 */
export interface QueryLicensesByOwnerResponse {
  /** licenses is the list of licenses owned by the address */
  licenses: License[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryBalanceRequest is the request for the BalanceOf RPC method */
export interface QueryBalanceRequest {
  /** owner is the address to query the balance for */
  owner: string;
}

/** QueryBalanceResponse is the response for the BalanceOf RPC method */
export interface QueryBalanceResponse {
  /** balance is the number of licenses owned */
  balance: bigint;
}

/** QueryOwnerRequest is the request for the OwnerOf RPC method */
export interface QueryOwnerRequest {
  /** id is the unique identifier of the license */
  id: bigint;
}

/** QueryOwnerResponse is the response for the OwnerOf RPC method */
export interface QueryOwnerResponse {
  /** owner is the address that owns the license */
  owner: string;
}

/**
 * QueryTokenByOwnerIndexRequest is the request for the TokenOfOwnerByIndex
 * RPC method
 */
export interface QueryTokenByOwnerIndexRequest {
  /** owner is the address that owns the licenses */
  owner: string;
  /** index is the index in the owner's token list */
  index: bigint;
}

/**
 * QueryTokenByOwnerIndexResponse is the response for the TokenOfOwnerByIndex
 * RPC method
 */
export interface QueryTokenByOwnerIndexResponse {
  /** id is the license ID at the given index */
  id: bigint;
}

/** QueryOwnedByRequest is the request for the OwnedBy RPC method */
export interface QueryOwnedByRequest {
  /** owner is the address to query licenses for */
  owner: string;
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryOwnedByResponse is the response for the OwnedBy RPC method */
export interface QueryOwnedByResponse {
  /** license_ids is the list of license IDs owned by the address */
  licenseIds: bigint[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryTotalSupplyRequest is the request for the TotalSupply RPC method */
export interface QueryTotalSupplyRequest {
}

/** QueryTotalSupplyResponse is the response for the TotalSupply RPC method */
export interface QueryTotalSupplyResponse {
  /** total_supply is the total number of active licenses */
  totalSupply: bigint;
}

/** QueryIsActiveRequest is the request for the IsActive RPC method */
export interface QueryIsActiveRequest {
  /** id is the unique identifier of the license */
  id: bigint;
}

/** QueryIsActiveResponse is the response for the IsActive RPC method */
export interface QueryIsActiveResponse {
  /** is_active indicates whether the license is active */
  isActive: boolean;
}

/** QueryParamsRequest is the request for the Params RPC method */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is the response for the Params RPC method */
export interface QueryParamsResponse {
  /** params are the module parameters */
  params: Params | undefined;
}

/** QueryMintersRequest is the request for the Minters RPC method */
export interface QueryMintersRequest {
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryMintersResponse is the response for the Minters RPC method */
export interface QueryMintersResponse {
  /** minters is the list of authorized minter addresses */
  minters: string[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryKYCApproversRequest is the request for the KYCApprovers RPC method */
export interface QueryKYCApproversRequest {
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryKYCApproversResponse is the response for the KYCApprovers RPC method */
export interface QueryKYCApproversResponse {
  /** approvers is the list of authorized KYC approver addresses */
  approvers: string[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryTransferUnlockTimeRequest is the request for the TransferUnlockTime RPC
 * method
 */
export interface QueryTransferUnlockTimeRequest {
}

/**
 * QueryTransferUnlockTimeResponse is the response for the TransferUnlockTime
 * RPC method
 */
export interface QueryTransferUnlockTimeResponse {
  /** unlock_time is the global time when all licenses become transferable */
  unlockTime: Date | undefined;
}

/** QueryApprovedMembersRequest is the request for the ApprovedMembers RPC method */
export interface QueryApprovedMembersRequest {
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/**
 * QueryApprovedMembersResponse is the response for the ApprovedMembers RPC
 * method
 */
export interface QueryApprovedMembersResponse {
  /** members is the list of approved DAO member addresses */
  members: string[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/**
 * QueryIsApprovedMemberRequest is the request for the IsApprovedMember RPC
 * method
 */
export interface QueryIsApprovedMemberRequest {
  /** address is the address to check */
  address: string;
}

/**
 * QueryIsApprovedMemberResponse is the response for the IsApprovedMember RPC
 * method
 */
export interface QueryIsApprovedMemberResponse {
  /** is_approved indicates whether the address is an approved member */
  isApproved: boolean;
}

/** QueryIsKYCApproverRequest is the request for the IsKYCApprover RPC method */
export interface QueryIsKYCApproverRequest {
  /** address is the address to check */
  address: string;
}

/** QueryIsKYCApproverResponse is the response for the IsKYCApprover RPC method */
export interface QueryIsKYCApproverResponse {
  /** is_approver indicates whether the address is a KYC approver */
  isApprover: boolean;
}

/**
 * QueryActiveLicenseCountAtRequest is the request for the ActiveLicenseCountAt
 * RPC method
 */
export interface QueryActiveLicenseCountAtRequest {
  /** owner is the address to query license count for */
  owner: string;
  /** snapshot_time is the time to query at */
  snapshotTime: Date | undefined;
}

/**
 * QueryActiveLicenseCountAtResponse is the response for the
 * ActiveLicenseCountAt RPC method
 */
export interface QueryActiveLicenseCountAtResponse {
  /** count is the number of active licenses owned at the snapshot time */
  count: bigint;
}

function createBaseQueryLicenseRequest(): QueryLicenseRequest {
  return { id: 0n };
}

export const QueryLicenseRequest: MessageFns<QueryLicenseRequest> = {
  encode(message: QueryLicenseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseRequest {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: QueryLicenseRequest): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseRequest>, I>>(base?: I): QueryLicenseRequest {
    return QueryLicenseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseRequest>, I>>(object: I): QueryLicenseRequest {
    const message = createBaseQueryLicenseRequest();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseQueryLicenseResponse(): QueryLicenseResponse {
  return { license: undefined };
}

export const QueryLicenseResponse: MessageFns<QueryLicenseResponse> = {
  encode(message: QueryLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.license !== undefined) {
      License.encode(message.license, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.license = License.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseResponse {
    return { license: isSet(object.license) ? License.fromJSON(object.license) : undefined };
  },

  toJSON(message: QueryLicenseResponse): unknown {
    const obj: any = {};
    if (message.license !== undefined) {
      obj.license = License.toJSON(message.license);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseResponse>, I>>(base?: I): QueryLicenseResponse {
    return QueryLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseResponse>, I>>(object: I): QueryLicenseResponse {
    const message = createBaseQueryLicenseResponse();
    message.license = (object.license !== undefined && object.license !== null)
      ? License.fromPartial(object.license)
      : undefined;
    return message;
  },
};

function createBaseQueryLicensesRequest(): QueryLicensesRequest {
  return { status: 0, pagination: undefined };
}

export const QueryLicensesRequest: MessageFns<QueryLicensesRequest> = {
  encode(message: QueryLicensesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensesRequest {
    return {
      status: isSet(object.status) ? licenseStatusFromJSON(object.status) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryLicensesRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = licenseStatusToJSON(message.status);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensesRequest>, I>>(base?: I): QueryLicensesRequest {
    return QueryLicensesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensesRequest>, I>>(object: I): QueryLicensesRequest {
    const message = createBaseQueryLicensesRequest();
    message.status = object.status ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryLicensesResponse(): QueryLicensesResponse {
  return { licenses: [], pagination: undefined };
}

export const QueryLicensesResponse: MessageFns<QueryLicensesResponse> = {
  encode(message: QueryLicensesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.licenses) {
      License.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.licenses.push(License.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensesResponse {
    return {
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => License.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryLicensesResponse): unknown {
    const obj: any = {};
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => License.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensesResponse>, I>>(base?: I): QueryLicensesResponse {
    return QueryLicensesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensesResponse>, I>>(object: I): QueryLicensesResponse {
    const message = createBaseQueryLicensesResponse();
    message.licenses = object.licenses?.map((e) => License.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryLicensesByOwnerRequest(): QueryLicensesByOwnerRequest {
  return { owner: "", pagination: undefined };
}

export const QueryLicensesByOwnerRequest: MessageFns<QueryLicensesByOwnerRequest> = {
  encode(message: QueryLicensesByOwnerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensesByOwnerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensesByOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensesByOwnerRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryLicensesByOwnerRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensesByOwnerRequest>, I>>(base?: I): QueryLicensesByOwnerRequest {
    return QueryLicensesByOwnerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensesByOwnerRequest>, I>>(object: I): QueryLicensesByOwnerRequest {
    const message = createBaseQueryLicensesByOwnerRequest();
    message.owner = object.owner ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryLicensesByOwnerResponse(): QueryLicensesByOwnerResponse {
  return { licenses: [], pagination: undefined };
}

export const QueryLicensesByOwnerResponse: MessageFns<QueryLicensesByOwnerResponse> = {
  encode(message: QueryLicensesByOwnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.licenses) {
      License.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensesByOwnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensesByOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.licenses.push(License.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensesByOwnerResponse {
    return {
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => License.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryLicensesByOwnerResponse): unknown {
    const obj: any = {};
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => License.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensesByOwnerResponse>, I>>(base?: I): QueryLicensesByOwnerResponse {
    return QueryLicensesByOwnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensesByOwnerResponse>, I>>(object: I): QueryLicensesByOwnerResponse {
    const message = createBaseQueryLicensesByOwnerResponse();
    message.licenses = object.licenses?.map((e) => License.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryBalanceRequest(): QueryBalanceRequest {
  return { owner: "" };
}

export const QueryBalanceRequest: MessageFns<QueryBalanceRequest> = {
  encode(message: QueryBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: QueryBalanceRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(base?: I): QueryBalanceRequest {
    return QueryBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(object: I): QueryBalanceRequest {
    const message = createBaseQueryBalanceRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryBalanceResponse(): QueryBalanceResponse {
  return { balance: 0n };
}

export const QueryBalanceResponse: MessageFns<QueryBalanceResponse> = {
  encode(message: QueryBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== 0n) {
      if (BigInt.asUintN(64, message.balance) !== message.balance) {
        throw new globalThis.Error("value provided for field message.balance of type uint64 too large");
      }
      writer.uint32(8).uint64(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.balance = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceResponse {
    return { balance: isSet(object.balance) ? BigInt(object.balance) : 0n };
  },

  toJSON(message: QueryBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== 0n) {
      obj.balance = message.balance.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(base?: I): QueryBalanceResponse {
    return QueryBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(object: I): QueryBalanceResponse {
    const message = createBaseQueryBalanceResponse();
    message.balance = object.balance ?? 0n;
    return message;
  },
};

function createBaseQueryOwnerRequest(): QueryOwnerRequest {
  return { id: 0n };
}

export const QueryOwnerRequest: MessageFns<QueryOwnerRequest> = {
  encode(message: QueryOwnerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerRequest {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: QueryOwnerRequest): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerRequest>, I>>(base?: I): QueryOwnerRequest {
    return QueryOwnerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerRequest>, I>>(object: I): QueryOwnerRequest {
    const message = createBaseQueryOwnerRequest();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseQueryOwnerResponse(): QueryOwnerResponse {
  return { owner: "" };
}

export const QueryOwnerResponse: MessageFns<QueryOwnerResponse> = {
  encode(message: QueryOwnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerResponse {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: QueryOwnerResponse): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerResponse>, I>>(base?: I): QueryOwnerResponse {
    return QueryOwnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerResponse>, I>>(object: I): QueryOwnerResponse {
    const message = createBaseQueryOwnerResponse();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryTokenByOwnerIndexRequest(): QueryTokenByOwnerIndexRequest {
  return { owner: "", index: 0n };
}

export const QueryTokenByOwnerIndexRequest: MessageFns<QueryTokenByOwnerIndexRequest> = {
  encode(message: QueryTokenByOwnerIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.index !== 0n) {
      if (BigInt.asUintN(64, message.index) !== message.index) {
        throw new globalThis.Error("value provided for field message.index of type uint64 too large");
      }
      writer.uint32(16).uint64(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenByOwnerIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenByOwnerIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenByOwnerIndexRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      index: isSet(object.index) ? BigInt(object.index) : 0n,
    };
  },

  toJSON(message: QueryTokenByOwnerIndexRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.index !== 0n) {
      obj.index = message.index.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTokenByOwnerIndexRequest>, I>>(base?: I): QueryTokenByOwnerIndexRequest {
    return QueryTokenByOwnerIndexRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTokenByOwnerIndexRequest>, I>>(
    object: I,
  ): QueryTokenByOwnerIndexRequest {
    const message = createBaseQueryTokenByOwnerIndexRequest();
    message.owner = object.owner ?? "";
    message.index = object.index ?? 0n;
    return message;
  },
};

function createBaseQueryTokenByOwnerIndexResponse(): QueryTokenByOwnerIndexResponse {
  return { id: 0n };
}

export const QueryTokenByOwnerIndexResponse: MessageFns<QueryTokenByOwnerIndexResponse> = {
  encode(message: QueryTokenByOwnerIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenByOwnerIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenByOwnerIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenByOwnerIndexResponse {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: QueryTokenByOwnerIndexResponse): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTokenByOwnerIndexResponse>, I>>(base?: I): QueryTokenByOwnerIndexResponse {
    return QueryTokenByOwnerIndexResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTokenByOwnerIndexResponse>, I>>(
    object: I,
  ): QueryTokenByOwnerIndexResponse {
    const message = createBaseQueryTokenByOwnerIndexResponse();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseQueryOwnedByRequest(): QueryOwnedByRequest {
  return { owner: "", pagination: undefined };
}

export const QueryOwnedByRequest: MessageFns<QueryOwnedByRequest> = {
  encode(message: QueryOwnedByRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnedByRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnedByRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnedByRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryOwnedByRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnedByRequest>, I>>(base?: I): QueryOwnedByRequest {
    return QueryOwnedByRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnedByRequest>, I>>(object: I): QueryOwnedByRequest {
    const message = createBaseQueryOwnedByRequest();
    message.owner = object.owner ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOwnedByResponse(): QueryOwnedByResponse {
  return { licenseIds: [], pagination: undefined };
}

export const QueryOwnedByResponse: MessageFns<QueryOwnedByResponse> = {
  encode(message: QueryOwnedByResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.licenseIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field licenseIds of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnedByResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnedByResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.licenseIds.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseIds.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnedByResponse {
    return {
      licenseIds: globalThis.Array.isArray(object?.licenseIds)
        ? object.licenseIds.map((e: any) => BigInt(e))
        : globalThis.Array.isArray(object?.license_ids)
        ? object.license_ids.map((e: any) => BigInt(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryOwnedByResponse): unknown {
    const obj: any = {};
    if (message.licenseIds?.length) {
      obj.licenseIds = message.licenseIds.map((e) => e.toString());
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnedByResponse>, I>>(base?: I): QueryOwnedByResponse {
    return QueryOwnedByResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnedByResponse>, I>>(object: I): QueryOwnedByResponse {
    const message = createBaseQueryOwnedByResponse();
    message.licenseIds = object.licenseIds?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryTotalSupplyRequest(): QueryTotalSupplyRequest {
  return {};
}

export const QueryTotalSupplyRequest: MessageFns<QueryTotalSupplyRequest> = {
  encode(_: QueryTotalSupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalSupplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryTotalSupplyRequest {
    return {};
  },

  toJSON(_: QueryTotalSupplyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(base?: I): QueryTotalSupplyRequest {
    return QueryTotalSupplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(_: I): QueryTotalSupplyRequest {
    const message = createBaseQueryTotalSupplyRequest();
    return message;
  },
};

function createBaseQueryTotalSupplyResponse(): QueryTotalSupplyResponse {
  return { totalSupply: 0n };
}

export const QueryTotalSupplyResponse: MessageFns<QueryTotalSupplyResponse> = {
  encode(message: QueryTotalSupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalSupply !== 0n) {
      if (BigInt.asUintN(64, message.totalSupply) !== message.totalSupply) {
        throw new globalThis.Error("value provided for field message.totalSupply of type uint64 too large");
      }
      writer.uint32(8).uint64(message.totalSupply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalSupplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalSupply = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTotalSupplyResponse {
    return {
      totalSupply: isSet(object.totalSupply)
        ? BigInt(object.totalSupply)
        : isSet(object.total_supply)
        ? BigInt(object.total_supply)
        : 0n,
    };
  },

  toJSON(message: QueryTotalSupplyResponse): unknown {
    const obj: any = {};
    if (message.totalSupply !== 0n) {
      obj.totalSupply = message.totalSupply.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(base?: I): QueryTotalSupplyResponse {
    return QueryTotalSupplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(object: I): QueryTotalSupplyResponse {
    const message = createBaseQueryTotalSupplyResponse();
    message.totalSupply = object.totalSupply ?? 0n;
    return message;
  },
};

function createBaseQueryIsActiveRequest(): QueryIsActiveRequest {
  return { id: 0n };
}

export const QueryIsActiveRequest: MessageFns<QueryIsActiveRequest> = {
  encode(message: QueryIsActiveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsActiveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsActiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsActiveRequest {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: QueryIsActiveRequest): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsActiveRequest>, I>>(base?: I): QueryIsActiveRequest {
    return QueryIsActiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsActiveRequest>, I>>(object: I): QueryIsActiveRequest {
    const message = createBaseQueryIsActiveRequest();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseQueryIsActiveResponse(): QueryIsActiveResponse {
  return { isActive: false };
}

export const QueryIsActiveResponse: MessageFns<QueryIsActiveResponse> = {
  encode(message: QueryIsActiveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsActiveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsActiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsActiveResponse {
    return {
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: QueryIsActiveResponse): unknown {
    const obj: any = {};
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsActiveResponse>, I>>(base?: I): QueryIsActiveResponse {
    return QueryIsActiveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsActiveResponse>, I>>(object: I): QueryIsActiveResponse {
    const message = createBaseQueryIsActiveResponse();
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryMintersRequest(): QueryMintersRequest {
  return { pagination: undefined };
}

export const QueryMintersRequest: MessageFns<QueryMintersRequest> = {
  encode(message: QueryMintersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMintersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMintersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMintersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryMintersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMintersRequest>, I>>(base?: I): QueryMintersRequest {
    return QueryMintersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMintersRequest>, I>>(object: I): QueryMintersRequest {
    const message = createBaseQueryMintersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryMintersResponse(): QueryMintersResponse {
  return { minters: [], pagination: undefined };
}

export const QueryMintersResponse: MessageFns<QueryMintersResponse> = {
  encode(message: QueryMintersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.minters) {
      writer.uint32(10).string(v!);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMintersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMintersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minters.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMintersResponse {
    return {
      minters: globalThis.Array.isArray(object?.minters) ? object.minters.map((e: any) => globalThis.String(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryMintersResponse): unknown {
    const obj: any = {};
    if (message.minters?.length) {
      obj.minters = message.minters;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMintersResponse>, I>>(base?: I): QueryMintersResponse {
    return QueryMintersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMintersResponse>, I>>(object: I): QueryMintersResponse {
    const message = createBaseQueryMintersResponse();
    message.minters = object.minters?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKYCApproversRequest(): QueryKYCApproversRequest {
  return { pagination: undefined };
}

export const QueryKYCApproversRequest: MessageFns<QueryKYCApproversRequest> = {
  encode(message: QueryKYCApproversRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKYCApproversRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKYCApproversRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKYCApproversRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryKYCApproversRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKYCApproversRequest>, I>>(base?: I): QueryKYCApproversRequest {
    return QueryKYCApproversRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKYCApproversRequest>, I>>(object: I): QueryKYCApproversRequest {
    const message = createBaseQueryKYCApproversRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKYCApproversResponse(): QueryKYCApproversResponse {
  return { approvers: [], pagination: undefined };
}

export const QueryKYCApproversResponse: MessageFns<QueryKYCApproversResponse> = {
  encode(message: QueryKYCApproversResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.approvers) {
      writer.uint32(10).string(v!);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKYCApproversResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKYCApproversResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approvers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKYCApproversResponse {
    return {
      approvers: globalThis.Array.isArray(object?.approvers)
        ? object.approvers.map((e: any) => globalThis.String(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryKYCApproversResponse): unknown {
    const obj: any = {};
    if (message.approvers?.length) {
      obj.approvers = message.approvers;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKYCApproversResponse>, I>>(base?: I): QueryKYCApproversResponse {
    return QueryKYCApproversResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKYCApproversResponse>, I>>(object: I): QueryKYCApproversResponse {
    const message = createBaseQueryKYCApproversResponse();
    message.approvers = object.approvers?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryTransferUnlockTimeRequest(): QueryTransferUnlockTimeRequest {
  return {};
}

export const QueryTransferUnlockTimeRequest: MessageFns<QueryTransferUnlockTimeRequest> = {
  encode(_: QueryTransferUnlockTimeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTransferUnlockTimeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTransferUnlockTimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryTransferUnlockTimeRequest {
    return {};
  },

  toJSON(_: QueryTransferUnlockTimeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTransferUnlockTimeRequest>, I>>(base?: I): QueryTransferUnlockTimeRequest {
    return QueryTransferUnlockTimeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTransferUnlockTimeRequest>, I>>(_: I): QueryTransferUnlockTimeRequest {
    const message = createBaseQueryTransferUnlockTimeRequest();
    return message;
  },
};

function createBaseQueryTransferUnlockTimeResponse(): QueryTransferUnlockTimeResponse {
  return { unlockTime: undefined };
}

export const QueryTransferUnlockTimeResponse: MessageFns<QueryTransferUnlockTimeResponse> = {
  encode(message: QueryTransferUnlockTimeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unlockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.unlockTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTransferUnlockTimeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTransferUnlockTimeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTransferUnlockTimeResponse {
    return {
      unlockTime: isSet(object.unlockTime)
        ? fromJsonTimestamp(object.unlockTime)
        : isSet(object.unlock_time)
        ? fromJsonTimestamp(object.unlock_time)
        : undefined,
    };
  },

  toJSON(message: QueryTransferUnlockTimeResponse): unknown {
    const obj: any = {};
    if (message.unlockTime !== undefined) {
      obj.unlockTime = message.unlockTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTransferUnlockTimeResponse>, I>>(base?: I): QueryTransferUnlockTimeResponse {
    return QueryTransferUnlockTimeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTransferUnlockTimeResponse>, I>>(
    object: I,
  ): QueryTransferUnlockTimeResponse {
    const message = createBaseQueryTransferUnlockTimeResponse();
    message.unlockTime = object.unlockTime ?? undefined;
    return message;
  },
};

function createBaseQueryApprovedMembersRequest(): QueryApprovedMembersRequest {
  return { pagination: undefined };
}

export const QueryApprovedMembersRequest: MessageFns<QueryApprovedMembersRequest> = {
  encode(message: QueryApprovedMembersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApprovedMembersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApprovedMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApprovedMembersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryApprovedMembersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryApprovedMembersRequest>, I>>(base?: I): QueryApprovedMembersRequest {
    return QueryApprovedMembersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryApprovedMembersRequest>, I>>(object: I): QueryApprovedMembersRequest {
    const message = createBaseQueryApprovedMembersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryApprovedMembersResponse(): QueryApprovedMembersResponse {
  return { members: [], pagination: undefined };
}

export const QueryApprovedMembersResponse: MessageFns<QueryApprovedMembersResponse> = {
  encode(message: QueryApprovedMembersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      writer.uint32(10).string(v!);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApprovedMembersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApprovedMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApprovedMembersResponse {
    return {
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => globalThis.String(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryApprovedMembersResponse): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryApprovedMembersResponse>, I>>(base?: I): QueryApprovedMembersResponse {
    return QueryApprovedMembersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryApprovedMembersResponse>, I>>(object: I): QueryApprovedMembersResponse {
    const message = createBaseQueryApprovedMembersResponse();
    message.members = object.members?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIsApprovedMemberRequest(): QueryIsApprovedMemberRequest {
  return { address: "" };
}

export const QueryIsApprovedMemberRequest: MessageFns<QueryIsApprovedMemberRequest> = {
  encode(message: QueryIsApprovedMemberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsApprovedMemberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsApprovedMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsApprovedMemberRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryIsApprovedMemberRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsApprovedMemberRequest>, I>>(base?: I): QueryIsApprovedMemberRequest {
    return QueryIsApprovedMemberRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsApprovedMemberRequest>, I>>(object: I): QueryIsApprovedMemberRequest {
    const message = createBaseQueryIsApprovedMemberRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryIsApprovedMemberResponse(): QueryIsApprovedMemberResponse {
  return { isApproved: false };
}

export const QueryIsApprovedMemberResponse: MessageFns<QueryIsApprovedMemberResponse> = {
  encode(message: QueryIsApprovedMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isApproved !== false) {
      writer.uint32(8).bool(message.isApproved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsApprovedMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsApprovedMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isApproved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsApprovedMemberResponse {
    return {
      isApproved: isSet(object.isApproved)
        ? globalThis.Boolean(object.isApproved)
        : isSet(object.is_approved)
        ? globalThis.Boolean(object.is_approved)
        : false,
    };
  },

  toJSON(message: QueryIsApprovedMemberResponse): unknown {
    const obj: any = {};
    if (message.isApproved !== false) {
      obj.isApproved = message.isApproved;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsApprovedMemberResponse>, I>>(base?: I): QueryIsApprovedMemberResponse {
    return QueryIsApprovedMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsApprovedMemberResponse>, I>>(
    object: I,
  ): QueryIsApprovedMemberResponse {
    const message = createBaseQueryIsApprovedMemberResponse();
    message.isApproved = object.isApproved ?? false;
    return message;
  },
};

function createBaseQueryIsKYCApproverRequest(): QueryIsKYCApproverRequest {
  return { address: "" };
}

export const QueryIsKYCApproverRequest: MessageFns<QueryIsKYCApproverRequest> = {
  encode(message: QueryIsKYCApproverRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsKYCApproverRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsKYCApproverRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsKYCApproverRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryIsKYCApproverRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsKYCApproverRequest>, I>>(base?: I): QueryIsKYCApproverRequest {
    return QueryIsKYCApproverRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsKYCApproverRequest>, I>>(object: I): QueryIsKYCApproverRequest {
    const message = createBaseQueryIsKYCApproverRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryIsKYCApproverResponse(): QueryIsKYCApproverResponse {
  return { isApprover: false };
}

export const QueryIsKYCApproverResponse: MessageFns<QueryIsKYCApproverResponse> = {
  encode(message: QueryIsKYCApproverResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isApprover !== false) {
      writer.uint32(8).bool(message.isApprover);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIsKYCApproverResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsKYCApproverResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isApprover = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsKYCApproverResponse {
    return {
      isApprover: isSet(object.isApprover)
        ? globalThis.Boolean(object.isApprover)
        : isSet(object.is_approver)
        ? globalThis.Boolean(object.is_approver)
        : false,
    };
  },

  toJSON(message: QueryIsKYCApproverResponse): unknown {
    const obj: any = {};
    if (message.isApprover !== false) {
      obj.isApprover = message.isApprover;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsKYCApproverResponse>, I>>(base?: I): QueryIsKYCApproverResponse {
    return QueryIsKYCApproverResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsKYCApproverResponse>, I>>(object: I): QueryIsKYCApproverResponse {
    const message = createBaseQueryIsKYCApproverResponse();
    message.isApprover = object.isApprover ?? false;
    return message;
  },
};

function createBaseQueryActiveLicenseCountAtRequest(): QueryActiveLicenseCountAtRequest {
  return { owner: "", snapshotTime: undefined };
}

export const QueryActiveLicenseCountAtRequest: MessageFns<QueryActiveLicenseCountAtRequest> = {
  encode(message: QueryActiveLicenseCountAtRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.snapshotTime !== undefined) {
      Timestamp.encode(toTimestamp(message.snapshotTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveLicenseCountAtRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveLicenseCountAtRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshotTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryActiveLicenseCountAtRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      snapshotTime: isSet(object.snapshotTime)
        ? fromJsonTimestamp(object.snapshotTime)
        : isSet(object.snapshot_time)
        ? fromJsonTimestamp(object.snapshot_time)
        : undefined,
    };
  },

  toJSON(message: QueryActiveLicenseCountAtRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.snapshotTime !== undefined) {
      obj.snapshotTime = message.snapshotTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryActiveLicenseCountAtRequest>, I>>(
    base?: I,
  ): QueryActiveLicenseCountAtRequest {
    return QueryActiveLicenseCountAtRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryActiveLicenseCountAtRequest>, I>>(
    object: I,
  ): QueryActiveLicenseCountAtRequest {
    const message = createBaseQueryActiveLicenseCountAtRequest();
    message.owner = object.owner ?? "";
    message.snapshotTime = object.snapshotTime ?? undefined;
    return message;
  },
};

function createBaseQueryActiveLicenseCountAtResponse(): QueryActiveLicenseCountAtResponse {
  return { count: 0n };
}

export const QueryActiveLicenseCountAtResponse: MessageFns<QueryActiveLicenseCountAtResponse> = {
  encode(message: QueryActiveLicenseCountAtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0n) {
      if (BigInt.asUintN(64, message.count) !== message.count) {
        throw new globalThis.Error("value provided for field message.count of type uint64 too large");
      }
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveLicenseCountAtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveLicenseCountAtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryActiveLicenseCountAtResponse {
    return { count: isSet(object.count) ? BigInt(object.count) : 0n };
  },

  toJSON(message: QueryActiveLicenseCountAtResponse): unknown {
    const obj: any = {};
    if (message.count !== 0n) {
      obj.count = message.count.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryActiveLicenseCountAtResponse>, I>>(
    base?: I,
  ): QueryActiveLicenseCountAtResponse {
    return QueryActiveLicenseCountAtResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryActiveLicenseCountAtResponse>, I>>(
    object: I,
  ): QueryActiveLicenseCountAtResponse {
    const message = createBaseQueryActiveLicenseCountAtResponse();
    message.count = object.count ?? 0n;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
