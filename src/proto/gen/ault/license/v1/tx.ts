// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/license/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./license";

export const protobufPackage = "ault.license.v1";

/** MsgMintLicense defines a message to mint a new license */
export interface MsgMintLicense {
  /** minter is the address of the authorized minter */
  minter: string;
  /** to is the address that will receive the license */
  to: string;
  /** uri is the metadata URI for the license */
  uri: string;
  /** reason is the reason for minting (for audit trail) */
  reason: string;
}

/** MsgMintLicenseResponse defines the response for MsgMintLicense */
export interface MsgMintLicenseResponse {
  /** id is the unique identifier of the newly minted license */
  id: bigint;
}

/** MsgBatchMintLicense defines a message to mint multiple licenses */
export interface MsgBatchMintLicense {
  /** minter is the address of the authorized minter */
  minter: string;
  /** to is the list of addresses that will receive licenses */
  to: string[];
  /** uri is the list of metadata URIs for the licenses */
  uri: string[];
  /** reason is the reason for minting (for audit trail) */
  reason: string;
}

/** MsgBatchMintLicenseResponse defines the response for MsgBatchMintLicense */
export interface MsgBatchMintLicenseResponse {
  /** ids is the list of unique identifiers of the newly minted licenses */
  ids: bigint[];
}

/** MsgRevokeLicense defines a message to revoke a license */
export interface MsgRevokeLicense {
  /** authority is the address of the module authority */
  authority: string;
  /** id is the unique identifier of the license to revoke */
  id: bigint;
  /** reason is the reason for revoking (for audit trail) */
  reason: string;
}

/** MsgRevokeLicenseResponse defines the response for MsgRevokeLicense */
export interface MsgRevokeLicenseResponse {
}

/** MsgBurnLicense defines a message to burn a license */
export interface MsgBurnLicense {
  /** authority is the address of the module authority */
  authority: string;
  /** id is the unique identifier of the license to burn */
  id: bigint;
  /** reason is the reason for burning (for audit trail) */
  reason: string;
}

/** MsgBurnLicenseResponse defines the response for MsgBurnLicense */
export interface MsgBurnLicenseResponse {
}

/** MsgSetTokenURI defines a message to update a license's metadata URI */
export interface MsgSetTokenURI {
  /** minter can be either module authority (governance) or an authorized minter */
  minter: string;
  /** id is the unique identifier of the license */
  id: bigint;
  /** uri is the new metadata URI */
  uri: string;
}

/** MsgSetTokenURIResponse defines the response for MsgSetTokenURI */
export interface MsgSetTokenURIResponse {
}

/** MsgSetMinters defines a message to update the set of authorized minters */
export interface MsgSetMinters {
  /** authority is the address of the module authority */
  authority: string;
  /** add is the list of addresses to add as minters */
  add: string[];
  /** remove is the list of addresses to remove from minters */
  remove: string[];
}

/** MsgSetMintersResponse defines the response for MsgSetMinters */
export interface MsgSetMintersResponse {
}

/**
 * MsgUpdateParams defines a message to update the module parameters via
 * governance
 */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten)
   */
  authority: string;
  /** params are the new parameters */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse defines the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

/** MsgApproveMember defines a message to approve an address as a DAO member */
export interface MsgApproveMember {
  /** authority is the address of the module authority or authorized KYC approver */
  authority: string;
  /** member is the address to approve as a DAO member */
  member: string;
}

/** MsgApproveMemberResponse defines the response for MsgApproveMember */
export interface MsgApproveMemberResponse {
}

/** MsgRevokeMember defines a message to revoke DAO member status */
export interface MsgRevokeMember {
  /** authority is the address of the module authority or authorized KYC approver */
  authority: string;
  /** member is the address to revoke DAO member status from */
  member: string;
}

/** MsgRevokeMemberResponse defines the response for MsgRevokeMember */
export interface MsgRevokeMemberResponse {
}

/**
 * MsgBatchApproveMember defines a message to approve multiple addresses as DAO
 * members
 */
export interface MsgBatchApproveMember {
  /** authority is the address of the module authority or authorized KYC approver */
  authority: string;
  /** members is the list of addresses to approve as DAO members */
  members: string[];
}

/** MsgBatchApproveMemberResponse defines the response for MsgBatchApproveMember */
export interface MsgBatchApproveMemberResponse {
  /** successful_members contains the addresses that were successfully approved */
  successfulMembers: string[];
  /** failed_members contains the addresses that failed to be approved */
  failedMembers: string[];
}

/**
 * MsgBatchRevokeMember defines a message to revoke DAO member status from
 * multiple addresses
 */
export interface MsgBatchRevokeMember {
  /** authority is the address of the module authority or authorized KYC approver */
  authority: string;
  /** members is the list of addresses to revoke DAO member status from */
  members: string[];
}

/** MsgBatchRevokeMemberResponse defines the response for MsgBatchRevokeMember */
export interface MsgBatchRevokeMemberResponse {
  /** successful_members contains the addresses that were successfully revoked */
  successfulMembers: string[];
  /** failed_members contains the addresses that failed to be revoked */
  failedMembers: string[];
}

/**
 * MsgSetKYCApprovers defines a message to update the set of authorized KYC
 * approvers
 */
export interface MsgSetKYCApprovers {
  /** authority is the address of the module authority */
  authority: string;
  /** add is the list of addresses to add as KYC approvers */
  add: string[];
  /** remove is the list of addresses to remove from KYC approvers */
  remove: string[];
}

/** MsgSetKYCApproversResponse defines the response for MsgSetKYCApprovers */
export interface MsgSetKYCApproversResponse {
}

/** MsgTransferLicense transfers a license from the owner to a new address */
export interface MsgTransferLicense {
  /** from is the current owner of the license */
  from: string;
  /** to is the address that will receive the license */
  to: string;
  /** license_id is the ID of the license to transfer */
  licenseId: bigint;
  /** reason is an optional reason for the transfer (audit trail) */
  reason: string;
}

/** MsgTransferLicenseResponse defines the response for MsgTransferLicense */
export interface MsgTransferLicenseResponse {
}

function createBaseMsgMintLicense(): MsgMintLicense {
  return { minter: "", to: "", uri: "", reason: "" };
}

export const MsgMintLicense: MessageFns<MsgMintLicense> = {
  encode(message: MsgMintLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minter !== "") {
      writer.uint32(10).string(message.minter);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMintLicense {
    return {
      minter: isSet(object.minter) ? globalThis.String(object.minter) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgMintLicense): unknown {
    const obj: any = {};
    if (message.minter !== "") {
      obj.minter = message.minter;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMintLicense>, I>>(base?: I): MsgMintLicense {
    return MsgMintLicense.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMintLicense>, I>>(object: I): MsgMintLicense {
    const message = createBaseMsgMintLicense();
    message.minter = object.minter ?? "";
    message.to = object.to ?? "";
    message.uri = object.uri ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgMintLicenseResponse(): MsgMintLicenseResponse {
  return { id: 0n };
}

export const MsgMintLicenseResponse: MessageFns<MsgMintLicenseResponse> = {
  encode(message: MsgMintLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMintLicenseResponse {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: MsgMintLicenseResponse): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMintLicenseResponse>, I>>(base?: I): MsgMintLicenseResponse {
    return MsgMintLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMintLicenseResponse>, I>>(object: I): MsgMintLicenseResponse {
    const message = createBaseMsgMintLicenseResponse();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseMsgBatchMintLicense(): MsgBatchMintLicense {
  return { minter: "", to: [], uri: [], reason: "" };
}

export const MsgBatchMintLicense: MessageFns<MsgBatchMintLicense> = {
  encode(message: MsgBatchMintLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minter !== "") {
      writer.uint32(10).string(message.minter);
    }
    for (const v of message.to) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.uri) {
      writer.uint32(26).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchMintLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchMintLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchMintLicense {
    return {
      minter: isSet(object.minter) ? globalThis.String(object.minter) : "",
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => globalThis.String(e)) : [],
      uri: globalThis.Array.isArray(object?.uri) ? object.uri.map((e: any) => globalThis.String(e)) : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgBatchMintLicense): unknown {
    const obj: any = {};
    if (message.minter !== "") {
      obj.minter = message.minter;
    }
    if (message.to?.length) {
      obj.to = message.to;
    }
    if (message.uri?.length) {
      obj.uri = message.uri;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchMintLicense>, I>>(base?: I): MsgBatchMintLicense {
    return MsgBatchMintLicense.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchMintLicense>, I>>(object: I): MsgBatchMintLicense {
    const message = createBaseMsgBatchMintLicense();
    message.minter = object.minter ?? "";
    message.to = object.to?.map((e) => e) || [];
    message.uri = object.uri?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgBatchMintLicenseResponse(): MsgBatchMintLicenseResponse {
  return { ids: [] };
}

export const MsgBatchMintLicenseResponse: MessageFns<MsgBatchMintLicenseResponse> = {
  encode(message: MsgBatchMintLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field ids of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchMintLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchMintLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchMintLicenseResponse {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => BigInt(e)) : [] };
  },

  toJSON(message: MsgBatchMintLicenseResponse): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchMintLicenseResponse>, I>>(base?: I): MsgBatchMintLicenseResponse {
    return MsgBatchMintLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchMintLicenseResponse>, I>>(object: I): MsgBatchMintLicenseResponse {
    const message = createBaseMsgBatchMintLicenseResponse();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgRevokeLicense(): MsgRevokeLicense {
  return { authority: "", id: 0n, reason: "" };
}

export const MsgRevokeLicense: MessageFns<MsgRevokeLicense> = {
  encode(message: MsgRevokeLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeLicense {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgRevokeLicense): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRevokeLicense>, I>>(base?: I): MsgRevokeLicense {
    return MsgRevokeLicense.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRevokeLicense>, I>>(object: I): MsgRevokeLicense {
    const message = createBaseMsgRevokeLicense();
    message.authority = object.authority ?? "";
    message.id = object.id ?? 0n;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgRevokeLicenseResponse(): MsgRevokeLicenseResponse {
  return {};
}

export const MsgRevokeLicenseResponse: MessageFns<MsgRevokeLicenseResponse> = {
  encode(_: MsgRevokeLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeLicenseResponse {
    return {};
  },

  toJSON(_: MsgRevokeLicenseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRevokeLicenseResponse>, I>>(base?: I): MsgRevokeLicenseResponse {
    return MsgRevokeLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRevokeLicenseResponse>, I>>(_: I): MsgRevokeLicenseResponse {
    const message = createBaseMsgRevokeLicenseResponse();
    return message;
  },
};

function createBaseMsgBurnLicense(): MsgBurnLicense {
  return { authority: "", id: 0n, reason: "" };
}

export const MsgBurnLicense: MessageFns<MsgBurnLicense> = {
  encode(message: MsgBurnLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBurnLicense {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgBurnLicense): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurnLicense>, I>>(base?: I): MsgBurnLicense {
    return MsgBurnLicense.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurnLicense>, I>>(object: I): MsgBurnLicense {
    const message = createBaseMsgBurnLicense();
    message.authority = object.authority ?? "";
    message.id = object.id ?? 0n;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgBurnLicenseResponse(): MsgBurnLicenseResponse {
  return {};
}

export const MsgBurnLicenseResponse: MessageFns<MsgBurnLicenseResponse> = {
  encode(_: MsgBurnLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBurnLicenseResponse {
    return {};
  },

  toJSON(_: MsgBurnLicenseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurnLicenseResponse>, I>>(base?: I): MsgBurnLicenseResponse {
    return MsgBurnLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurnLicenseResponse>, I>>(_: I): MsgBurnLicenseResponse {
    const message = createBaseMsgBurnLicenseResponse();
    return message;
  },
};

function createBaseMsgSetTokenURI(): MsgSetTokenURI {
  return { minter: "", id: 0n, uri: "" };
}

export const MsgSetTokenURI: MessageFns<MsgSetTokenURI> = {
  encode(message: MsgSetTokenURI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minter !== "") {
      writer.uint32(10).string(message.minter);
    }
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetTokenURI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetTokenURI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetTokenURI {
    return {
      minter: isSet(object.minter) ? globalThis.String(object.minter) : "",
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: MsgSetTokenURI): unknown {
    const obj: any = {};
    if (message.minter !== "") {
      obj.minter = message.minter;
    }
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetTokenURI>, I>>(base?: I): MsgSetTokenURI {
    return MsgSetTokenURI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetTokenURI>, I>>(object: I): MsgSetTokenURI {
    const message = createBaseMsgSetTokenURI();
    message.minter = object.minter ?? "";
    message.id = object.id ?? 0n;
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseMsgSetTokenURIResponse(): MsgSetTokenURIResponse {
  return {};
}

export const MsgSetTokenURIResponse: MessageFns<MsgSetTokenURIResponse> = {
  encode(_: MsgSetTokenURIResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetTokenURIResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetTokenURIResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetTokenURIResponse {
    return {};
  },

  toJSON(_: MsgSetTokenURIResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetTokenURIResponse>, I>>(base?: I): MsgSetTokenURIResponse {
    return MsgSetTokenURIResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetTokenURIResponse>, I>>(_: I): MsgSetTokenURIResponse {
    const message = createBaseMsgSetTokenURIResponse();
    return message;
  },
};

function createBaseMsgSetMinters(): MsgSetMinters {
  return { authority: "", add: [], remove: [] };
}

export const MsgSetMinters: MessageFns<MsgSetMinters> = {
  encode(message: MsgSetMinters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.add) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.remove) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMinters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMinters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.add.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remove.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMinters {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      add: globalThis.Array.isArray(object?.add) ? object.add.map((e: any) => globalThis.String(e)) : [],
      remove: globalThis.Array.isArray(object?.remove) ? object.remove.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSetMinters): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.add?.length) {
      obj.add = message.add;
    }
    if (message.remove?.length) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMinters>, I>>(base?: I): MsgSetMinters {
    return MsgSetMinters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMinters>, I>>(object: I): MsgSetMinters {
    const message = createBaseMsgSetMinters();
    message.authority = object.authority ?? "";
    message.add = object.add?.map((e) => e) || [];
    message.remove = object.remove?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetMintersResponse(): MsgSetMintersResponse {
  return {};
}

export const MsgSetMintersResponse: MessageFns<MsgSetMintersResponse> = {
  encode(_: MsgSetMintersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMintersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMintersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetMintersResponse {
    return {};
  },

  toJSON(_: MsgSetMintersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMintersResponse>, I>>(base?: I): MsgSetMintersResponse {
    return MsgSetMintersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMintersResponse>, I>>(_: I): MsgSetMintersResponse {
    const message = createBaseMsgSetMintersResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgApproveMember(): MsgApproveMember {
  return { authority: "", member: "" };
}

export const MsgApproveMember: MessageFns<MsgApproveMember> = {
  encode(message: MsgApproveMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgApproveMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgApproveMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.member = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgApproveMember {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      member: isSet(object.member) ? globalThis.String(object.member) : "",
    };
  },

  toJSON(message: MsgApproveMember): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgApproveMember>, I>>(base?: I): MsgApproveMember {
    return MsgApproveMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgApproveMember>, I>>(object: I): MsgApproveMember {
    const message = createBaseMsgApproveMember();
    message.authority = object.authority ?? "";
    message.member = object.member ?? "";
    return message;
  },
};

function createBaseMsgApproveMemberResponse(): MsgApproveMemberResponse {
  return {};
}

export const MsgApproveMemberResponse: MessageFns<MsgApproveMemberResponse> = {
  encode(_: MsgApproveMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgApproveMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgApproveMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgApproveMemberResponse {
    return {};
  },

  toJSON(_: MsgApproveMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgApproveMemberResponse>, I>>(base?: I): MsgApproveMemberResponse {
    return MsgApproveMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgApproveMemberResponse>, I>>(_: I): MsgApproveMemberResponse {
    const message = createBaseMsgApproveMemberResponse();
    return message;
  },
};

function createBaseMsgRevokeMember(): MsgRevokeMember {
  return { authority: "", member: "" };
}

export const MsgRevokeMember: MessageFns<MsgRevokeMember> = {
  encode(message: MsgRevokeMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.member = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeMember {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      member: isSet(object.member) ? globalThis.String(object.member) : "",
    };
  },

  toJSON(message: MsgRevokeMember): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRevokeMember>, I>>(base?: I): MsgRevokeMember {
    return MsgRevokeMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRevokeMember>, I>>(object: I): MsgRevokeMember {
    const message = createBaseMsgRevokeMember();
    message.authority = object.authority ?? "";
    message.member = object.member ?? "";
    return message;
  },
};

function createBaseMsgRevokeMemberResponse(): MsgRevokeMemberResponse {
  return {};
}

export const MsgRevokeMemberResponse: MessageFns<MsgRevokeMemberResponse> = {
  encode(_: MsgRevokeMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeMemberResponse {
    return {};
  },

  toJSON(_: MsgRevokeMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRevokeMemberResponse>, I>>(base?: I): MsgRevokeMemberResponse {
    return MsgRevokeMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRevokeMemberResponse>, I>>(_: I): MsgRevokeMemberResponse {
    const message = createBaseMsgRevokeMemberResponse();
    return message;
  },
};

function createBaseMsgBatchApproveMember(): MsgBatchApproveMember {
  return { authority: "", members: [] };
}

export const MsgBatchApproveMember: MessageFns<MsgBatchApproveMember> = {
  encode(message: MsgBatchApproveMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.members) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchApproveMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchApproveMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.members.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchApproveMember {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgBatchApproveMember): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.members?.length) {
      obj.members = message.members;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchApproveMember>, I>>(base?: I): MsgBatchApproveMember {
    return MsgBatchApproveMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchApproveMember>, I>>(object: I): MsgBatchApproveMember {
    const message = createBaseMsgBatchApproveMember();
    message.authority = object.authority ?? "";
    message.members = object.members?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBatchApproveMemberResponse(): MsgBatchApproveMemberResponse {
  return { successfulMembers: [], failedMembers: [] };
}

export const MsgBatchApproveMemberResponse: MessageFns<MsgBatchApproveMemberResponse> = {
  encode(message: MsgBatchApproveMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.successfulMembers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.failedMembers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchApproveMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchApproveMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.successfulMembers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failedMembers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchApproveMemberResponse {
    return {
      successfulMembers: globalThis.Array.isArray(object?.successfulMembers)
        ? object.successfulMembers.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.successful_members)
        ? object.successful_members.map((e: any) => globalThis.String(e))
        : [],
      failedMembers: globalThis.Array.isArray(object?.failedMembers)
        ? object.failedMembers.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.failed_members)
        ? object.failed_members.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgBatchApproveMemberResponse): unknown {
    const obj: any = {};
    if (message.successfulMembers?.length) {
      obj.successfulMembers = message.successfulMembers;
    }
    if (message.failedMembers?.length) {
      obj.failedMembers = message.failedMembers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchApproveMemberResponse>, I>>(base?: I): MsgBatchApproveMemberResponse {
    return MsgBatchApproveMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchApproveMemberResponse>, I>>(
    object: I,
  ): MsgBatchApproveMemberResponse {
    const message = createBaseMsgBatchApproveMemberResponse();
    message.successfulMembers = object.successfulMembers?.map((e) => e) || [];
    message.failedMembers = object.failedMembers?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBatchRevokeMember(): MsgBatchRevokeMember {
  return { authority: "", members: [] };
}

export const MsgBatchRevokeMember: MessageFns<MsgBatchRevokeMember> = {
  encode(message: MsgBatchRevokeMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.members) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchRevokeMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchRevokeMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.members.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchRevokeMember {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgBatchRevokeMember): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.members?.length) {
      obj.members = message.members;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchRevokeMember>, I>>(base?: I): MsgBatchRevokeMember {
    return MsgBatchRevokeMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchRevokeMember>, I>>(object: I): MsgBatchRevokeMember {
    const message = createBaseMsgBatchRevokeMember();
    message.authority = object.authority ?? "";
    message.members = object.members?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBatchRevokeMemberResponse(): MsgBatchRevokeMemberResponse {
  return { successfulMembers: [], failedMembers: [] };
}

export const MsgBatchRevokeMemberResponse: MessageFns<MsgBatchRevokeMemberResponse> = {
  encode(message: MsgBatchRevokeMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.successfulMembers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.failedMembers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchRevokeMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchRevokeMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.successfulMembers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failedMembers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchRevokeMemberResponse {
    return {
      successfulMembers: globalThis.Array.isArray(object?.successfulMembers)
        ? object.successfulMembers.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.successful_members)
        ? object.successful_members.map((e: any) => globalThis.String(e))
        : [],
      failedMembers: globalThis.Array.isArray(object?.failedMembers)
        ? object.failedMembers.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.failed_members)
        ? object.failed_members.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgBatchRevokeMemberResponse): unknown {
    const obj: any = {};
    if (message.successfulMembers?.length) {
      obj.successfulMembers = message.successfulMembers;
    }
    if (message.failedMembers?.length) {
      obj.failedMembers = message.failedMembers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchRevokeMemberResponse>, I>>(base?: I): MsgBatchRevokeMemberResponse {
    return MsgBatchRevokeMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchRevokeMemberResponse>, I>>(object: I): MsgBatchRevokeMemberResponse {
    const message = createBaseMsgBatchRevokeMemberResponse();
    message.successfulMembers = object.successfulMembers?.map((e) => e) || [];
    message.failedMembers = object.failedMembers?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetKYCApprovers(): MsgSetKYCApprovers {
  return { authority: "", add: [], remove: [] };
}

export const MsgSetKYCApprovers: MessageFns<MsgSetKYCApprovers> = {
  encode(message: MsgSetKYCApprovers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.add) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.remove) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetKYCApprovers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetKYCApprovers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.add.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remove.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetKYCApprovers {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      add: globalThis.Array.isArray(object?.add) ? object.add.map((e: any) => globalThis.String(e)) : [],
      remove: globalThis.Array.isArray(object?.remove) ? object.remove.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSetKYCApprovers): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.add?.length) {
      obj.add = message.add;
    }
    if (message.remove?.length) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetKYCApprovers>, I>>(base?: I): MsgSetKYCApprovers {
    return MsgSetKYCApprovers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetKYCApprovers>, I>>(object: I): MsgSetKYCApprovers {
    const message = createBaseMsgSetKYCApprovers();
    message.authority = object.authority ?? "";
    message.add = object.add?.map((e) => e) || [];
    message.remove = object.remove?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetKYCApproversResponse(): MsgSetKYCApproversResponse {
  return {};
}

export const MsgSetKYCApproversResponse: MessageFns<MsgSetKYCApproversResponse> = {
  encode(_: MsgSetKYCApproversResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetKYCApproversResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetKYCApproversResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetKYCApproversResponse {
    return {};
  },

  toJSON(_: MsgSetKYCApproversResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetKYCApproversResponse>, I>>(base?: I): MsgSetKYCApproversResponse {
    return MsgSetKYCApproversResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetKYCApproversResponse>, I>>(_: I): MsgSetKYCApproversResponse {
    const message = createBaseMsgSetKYCApproversResponse();
    return message;
  },
};

function createBaseMsgTransferLicense(): MsgTransferLicense {
  return { from: "", to: "", licenseId: 0n, reason: "" };
}

export const MsgTransferLicense: MessageFns<MsgTransferLicense> = {
  encode(message: MsgTransferLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.licenseId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferLicense {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgTransferLicense): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferLicense>, I>>(base?: I): MsgTransferLicense {
    return MsgTransferLicense.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferLicense>, I>>(object: I): MsgTransferLicense {
    const message = createBaseMsgTransferLicense();
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.licenseId = object.licenseId ?? 0n;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgTransferLicenseResponse(): MsgTransferLicenseResponse {
  return {};
}

export const MsgTransferLicenseResponse: MessageFns<MsgTransferLicenseResponse> = {
  encode(_: MsgTransferLicenseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferLicenseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferLicenseResponse {
    return {};
  },

  toJSON(_: MsgTransferLicenseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferLicenseResponse>, I>>(base?: I): MsgTransferLicenseResponse {
    return MsgTransferLicenseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferLicenseResponse>, I>>(_: I): MsgTransferLicenseResponse {
    const message = createBaseMsgTransferLicenseResponse();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
