// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/miner/v1/genesis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { EpochInfo, LicenseInfo, MiningDelegation, OperatorInfo, OwnerVRFKey, Params, Winner } from "./miner";

export const protobufPackage = "ault.miner.v1";

/** GenesisState defines the miner module's genesis state */
export interface GenesisState {
  /** params contains all module parameters */
  params:
    | Params
    | undefined;
  /** current_epoch is the current epoch number */
  currentEpoch: bigint;
  /** current_threshold is the current threshold (Q.128 as bytes) */
  currentThreshold: Uint8Array;
  /** owner_keys contains registered owner VRF keys */
  ownerKeys: OwnerVRFKey[];
  /** last_submit_epochs tracks last submission per license */
  lastSubmitEpochs: LastSubmitEpoch[];
  /** epochs contains recent epoch info (ring buffer) */
  epochs: EpochInfo[];
  /** license_infos contains license stats (credits and payouts) for each epoch */
  licenseInfos: EpochLicenseInfo[];
  /** epoch_winners contains winners for each epoch */
  epochWinners: EpochWinnersInfo[];
  /** randao_mix is the current RANDAO mix value */
  randaoMix: Uint8Array;
  /** last_settled_epoch is the last epoch that was settled for payouts */
  lastSettledEpoch: bigint;
  /** operators contains registered mining operators */
  operators: OperatorInfo[];
  /** mining_delegations contains license to operator delegations */
  miningDelegations: MiningDelegation[];
  /** delegation_queue contains pending delegation changes */
  delegationQueue: MiningDelegation[];
  /**
   * epoch_start_time (seconds since Unix epoch) shifts the epoch clock start.
   *
   * Purpose: avoid pointless early emission accumulation and give initial
   * miners adequate time to onboard before emissions begin. Guidance: set this
   * to at least two weeks AFTER the actual chain launch time. Behavior: epochs
   * are calculated from this timestamp; before it, expected epoch stays at zero
   * and emissions remain paused.
   */
  epochStartTime: bigint;
  /** payout_queue contains pending payouts */
  payoutQueue: PayoutQueueItem[];
  /** rate_limits contains rate limit counts per epoch per license */
  rateLimits: RateLimitEntry[];
  /** last_delegation_epochs tracks last delegation change epoch per license */
  lastDelegationEpochs: LastDelegationEpochEntry[];
  /** signer_rate_limits contains free tx rate limit counts per epoch per signer */
  signerRateLimits: SignerRateLimitEntry[];
  /**
   * carryover_emission is accumulated emission from epochs with no eligible
   * payouts
   */
  carryoverEmission:
    | Coin
    | undefined;
  /** all_time_credits contains accumulated credits per license */
  allTimeCredits: AllTimeCreditsEntry[];
  /** all_time_payouts contains accumulated payouts per license */
  allTimePayouts: AllTimePayoutsEntry[];
}

/** LastSubmitEpoch tracks the last epoch a license submitted work */
export interface LastSubmitEpoch {
  /** license_id */
  licenseId: bigint;
  /** epoch number */
  epoch: bigint;
}

/** EpochLicenseInfo tracks license stats for genesis export/import */
export interface EpochLicenseInfo {
  /** epoch number */
  epoch: bigint;
  /** license_id */
  licenseId: bigint;
  /** license info (credits and payout) */
  info: LicenseInfo | undefined;
}

/** EpochWinnersInfo tracks winners for an epoch in genesis export/import */
export interface EpochWinnersInfo {
  /** epoch number */
  epoch: bigint;
  /** winners for this epoch (directly stored, no wrapper) */
  winners: Winner[];
}

/** PayoutQueueItem represents a pending payout in the queue */
export interface PayoutQueueItem {
  /** license_id */
  licenseId: bigint;
  /** epoch number */
  epoch: bigint;
  /** recipient address */
  recipient: string;
  /** amount as string */
  amount: string;
}

/** RateLimitEntry represents rate limit count for a license in an epoch */
export interface RateLimitEntry {
  /** epoch number */
  epoch: bigint;
  /** license_id */
  licenseId: bigint;
  /** count */
  count: number;
}

/** LastDelegationEpochEntry tracks the last delegation change epoch per license */
export interface LastDelegationEpochEntry {
  /** license_id */
  licenseId: bigint;
  /** epoch of last delegation change */
  epoch: bigint;
}

/**
 * SignerRateLimitEntry represents free tx rate limit count for a signer in an
 * epoch
 */
export interface SignerRateLimitEntry {
  /** epoch number */
  epoch: bigint;
  /** signer address */
  signer: Uint8Array;
  /** count */
  count: number;
}

/** AllTimeCreditsEntry tracks cumulative credits for a license */
export interface AllTimeCreditsEntry {
  /** license_id */
  licenseId: bigint;
  /** credits accumulated */
  credits: bigint;
}

/** AllTimePayoutsEntry tracks cumulative payouts for a license */
export interface AllTimePayoutsEntry {
  /** license_id */
  licenseId: bigint;
  /** payout accumulated */
  payout: string;
}

function createBaseGenesisState(): GenesisState {
  return {
    params: undefined,
    currentEpoch: 0n,
    currentThreshold: new Uint8Array(0),
    ownerKeys: [],
    lastSubmitEpochs: [],
    epochs: [],
    licenseInfos: [],
    epochWinners: [],
    randaoMix: new Uint8Array(0),
    lastSettledEpoch: 0n,
    operators: [],
    miningDelegations: [],
    delegationQueue: [],
    epochStartTime: 0n,
    payoutQueue: [],
    rateLimits: [],
    lastDelegationEpochs: [],
    signerRateLimits: [],
    carryoverEmission: undefined,
    allTimeCredits: [],
    allTimePayouts: [],
  };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.currentEpoch !== 0n) {
      if (BigInt.asUintN(64, message.currentEpoch) !== message.currentEpoch) {
        throw new globalThis.Error("value provided for field message.currentEpoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.currentEpoch);
    }
    if (message.currentThreshold.length !== 0) {
      writer.uint32(26).bytes(message.currentThreshold);
    }
    for (const v of message.ownerKeys) {
      OwnerVRFKey.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.lastSubmitEpochs) {
      LastSubmitEpoch.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.epochs) {
      EpochInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.licenseInfos) {
      EpochLicenseInfo.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.epochWinners) {
      EpochWinnersInfo.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.randaoMix.length !== 0) {
      writer.uint32(74).bytes(message.randaoMix);
    }
    if (message.lastSettledEpoch !== 0n) {
      if (BigInt.asUintN(64, message.lastSettledEpoch) !== message.lastSettledEpoch) {
        throw new globalThis.Error("value provided for field message.lastSettledEpoch of type uint64 too large");
      }
      writer.uint32(80).uint64(message.lastSettledEpoch);
    }
    for (const v of message.operators) {
      OperatorInfo.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.miningDelegations) {
      MiningDelegation.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.delegationQueue) {
      MiningDelegation.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.epochStartTime !== 0n) {
      if (BigInt.asIntN(64, message.epochStartTime) !== message.epochStartTime) {
        throw new globalThis.Error("value provided for field message.epochStartTime of type int64 too large");
      }
      writer.uint32(112).int64(message.epochStartTime);
    }
    for (const v of message.payoutQueue) {
      PayoutQueueItem.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.rateLimits) {
      RateLimitEntry.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.lastDelegationEpochs) {
      LastDelegationEpochEntry.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.signerRateLimits) {
      SignerRateLimitEntry.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.carryoverEmission !== undefined) {
      Coin.encode(message.carryoverEmission, writer.uint32(154).fork()).join();
    }
    for (const v of message.allTimeCredits) {
      AllTimeCreditsEntry.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.allTimePayouts) {
      AllTimePayoutsEntry.encode(v!, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentEpoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentThreshold = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerKeys.push(OwnerVRFKey.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastSubmitEpochs.push(LastSubmitEpoch.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.epochs.push(EpochInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.licenseInfos.push(EpochLicenseInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.epochWinners.push(EpochWinnersInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.randaoMix = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.lastSettledEpoch = reader.uint64() as bigint;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.operators.push(OperatorInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.miningDelegations.push(MiningDelegation.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.delegationQueue.push(MiningDelegation.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.epochStartTime = reader.int64() as bigint;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.payoutQueue.push(PayoutQueueItem.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.rateLimits.push(RateLimitEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.lastDelegationEpochs.push(LastDelegationEpochEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.signerRateLimits.push(SignerRateLimitEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.carryoverEmission = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.allTimeCredits.push(AllTimeCreditsEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.allTimePayouts.push(AllTimePayoutsEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      currentEpoch: isSet(object.currentEpoch)
        ? BigInt(object.currentEpoch)
        : isSet(object.current_epoch)
        ? BigInt(object.current_epoch)
        : 0n,
      currentThreshold: isSet(object.currentThreshold)
        ? bytesFromBase64(object.currentThreshold)
        : isSet(object.current_threshold)
        ? bytesFromBase64(object.current_threshold)
        : new Uint8Array(0),
      ownerKeys: globalThis.Array.isArray(object?.ownerKeys)
        ? object.ownerKeys.map((e: any) => OwnerVRFKey.fromJSON(e))
        : globalThis.Array.isArray(object?.owner_keys)
        ? object.owner_keys.map((e: any) => OwnerVRFKey.fromJSON(e))
        : [],
      lastSubmitEpochs: globalThis.Array.isArray(object?.lastSubmitEpochs)
        ? object.lastSubmitEpochs.map((e: any) => LastSubmitEpoch.fromJSON(e))
        : globalThis.Array.isArray(object?.last_submit_epochs)
        ? object.last_submit_epochs.map((e: any) => LastSubmitEpoch.fromJSON(e))
        : [],
      epochs: globalThis.Array.isArray(object?.epochs)
        ? object.epochs.map((e: any) => EpochInfo.fromJSON(e))
        : [],
      licenseInfos: globalThis.Array.isArray(object?.licenseInfos)
        ? object.licenseInfos.map((e: any) => EpochLicenseInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.license_infos)
        ? object.license_infos.map((e: any) => EpochLicenseInfo.fromJSON(e))
        : [],
      epochWinners: globalThis.Array.isArray(object?.epochWinners)
        ? object.epochWinners.map((e: any) => EpochWinnersInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.epoch_winners)
        ? object.epoch_winners.map((e: any) => EpochWinnersInfo.fromJSON(e))
        : [],
      randaoMix: isSet(object.randaoMix)
        ? bytesFromBase64(object.randaoMix)
        : isSet(object.randao_mix)
        ? bytesFromBase64(object.randao_mix)
        : new Uint8Array(0),
      lastSettledEpoch: isSet(object.lastSettledEpoch)
        ? BigInt(object.lastSettledEpoch)
        : isSet(object.last_settled_epoch)
        ? BigInt(object.last_settled_epoch)
        : 0n,
      operators: globalThis.Array.isArray(object?.operators)
        ? object.operators.map((e: any) => OperatorInfo.fromJSON(e))
        : [],
      miningDelegations: globalThis.Array.isArray(object?.miningDelegations)
        ? object.miningDelegations.map((e: any) => MiningDelegation.fromJSON(e))
        : globalThis.Array.isArray(object?.mining_delegations)
        ? object.mining_delegations.map((e: any) => MiningDelegation.fromJSON(e))
        : [],
      delegationQueue: globalThis.Array.isArray(object?.delegationQueue)
        ? object.delegationQueue.map((e: any) => MiningDelegation.fromJSON(e))
        : globalThis.Array.isArray(object?.delegation_queue)
        ? object.delegation_queue.map((e: any) => MiningDelegation.fromJSON(e))
        : [],
      epochStartTime: isSet(object.epochStartTime)
        ? BigInt(object.epochStartTime)
        : isSet(object.epoch_start_time)
        ? BigInt(object.epoch_start_time)
        : 0n,
      payoutQueue: globalThis.Array.isArray(object?.payoutQueue)
        ? object.payoutQueue.map((e: any) => PayoutQueueItem.fromJSON(e))
        : globalThis.Array.isArray(object?.payout_queue)
        ? object.payout_queue.map((e: any) => PayoutQueueItem.fromJSON(e))
        : [],
      rateLimits: globalThis.Array.isArray(object?.rateLimits)
        ? object.rateLimits.map((e: any) => RateLimitEntry.fromJSON(e))
        : globalThis.Array.isArray(object?.rate_limits)
        ? object.rate_limits.map((e: any) => RateLimitEntry.fromJSON(e))
        : [],
      lastDelegationEpochs: globalThis.Array.isArray(object?.lastDelegationEpochs)
        ? object.lastDelegationEpochs.map((e: any) => LastDelegationEpochEntry.fromJSON(e))
        : globalThis.Array.isArray(object?.last_delegation_epochs)
        ? object.last_delegation_epochs.map((e: any) => LastDelegationEpochEntry.fromJSON(e))
        : [],
      signerRateLimits: globalThis.Array.isArray(object?.signerRateLimits)
        ? object.signerRateLimits.map((e: any) => SignerRateLimitEntry.fromJSON(e))
        : globalThis.Array.isArray(object?.signer_rate_limits)
        ? object.signer_rate_limits.map((e: any) => SignerRateLimitEntry.fromJSON(e))
        : [],
      carryoverEmission: isSet(object.carryoverEmission)
        ? Coin.fromJSON(object.carryoverEmission)
        : isSet(object.carryover_emission)
        ? Coin.fromJSON(object.carryover_emission)
        : undefined,
      allTimeCredits: globalThis.Array.isArray(object?.allTimeCredits)
        ? object.allTimeCredits.map((e: any) => AllTimeCreditsEntry.fromJSON(e))
        : globalThis.Array.isArray(object?.all_time_credits)
        ? object.all_time_credits.map((e: any) => AllTimeCreditsEntry.fromJSON(e))
        : [],
      allTimePayouts: globalThis.Array.isArray(object?.allTimePayouts)
        ? object.allTimePayouts.map((e: any) => AllTimePayoutsEntry.fromJSON(e))
        : globalThis.Array.isArray(object?.all_time_payouts)
        ? object.all_time_payouts.map((e: any) => AllTimePayoutsEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.currentEpoch !== 0n) {
      obj.currentEpoch = message.currentEpoch.toString();
    }
    if (message.currentThreshold.length !== 0) {
      obj.currentThreshold = base64FromBytes(message.currentThreshold);
    }
    if (message.ownerKeys?.length) {
      obj.ownerKeys = message.ownerKeys.map((e) => OwnerVRFKey.toJSON(e));
    }
    if (message.lastSubmitEpochs?.length) {
      obj.lastSubmitEpochs = message.lastSubmitEpochs.map((e) => LastSubmitEpoch.toJSON(e));
    }
    if (message.epochs?.length) {
      obj.epochs = message.epochs.map((e) => EpochInfo.toJSON(e));
    }
    if (message.licenseInfos?.length) {
      obj.licenseInfos = message.licenseInfos.map((e) => EpochLicenseInfo.toJSON(e));
    }
    if (message.epochWinners?.length) {
      obj.epochWinners = message.epochWinners.map((e) => EpochWinnersInfo.toJSON(e));
    }
    if (message.randaoMix.length !== 0) {
      obj.randaoMix = base64FromBytes(message.randaoMix);
    }
    if (message.lastSettledEpoch !== 0n) {
      obj.lastSettledEpoch = message.lastSettledEpoch.toString();
    }
    if (message.operators?.length) {
      obj.operators = message.operators.map((e) => OperatorInfo.toJSON(e));
    }
    if (message.miningDelegations?.length) {
      obj.miningDelegations = message.miningDelegations.map((e) => MiningDelegation.toJSON(e));
    }
    if (message.delegationQueue?.length) {
      obj.delegationQueue = message.delegationQueue.map((e) => MiningDelegation.toJSON(e));
    }
    if (message.epochStartTime !== 0n) {
      obj.epochStartTime = message.epochStartTime.toString();
    }
    if (message.payoutQueue?.length) {
      obj.payoutQueue = message.payoutQueue.map((e) => PayoutQueueItem.toJSON(e));
    }
    if (message.rateLimits?.length) {
      obj.rateLimits = message.rateLimits.map((e) => RateLimitEntry.toJSON(e));
    }
    if (message.lastDelegationEpochs?.length) {
      obj.lastDelegationEpochs = message.lastDelegationEpochs.map((e) => LastDelegationEpochEntry.toJSON(e));
    }
    if (message.signerRateLimits?.length) {
      obj.signerRateLimits = message.signerRateLimits.map((e) => SignerRateLimitEntry.toJSON(e));
    }
    if (message.carryoverEmission !== undefined) {
      obj.carryoverEmission = Coin.toJSON(message.carryoverEmission);
    }
    if (message.allTimeCredits?.length) {
      obj.allTimeCredits = message.allTimeCredits.map((e) => AllTimeCreditsEntry.toJSON(e));
    }
    if (message.allTimePayouts?.length) {
      obj.allTimePayouts = message.allTimePayouts.map((e) => AllTimePayoutsEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(base?: I): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(object: I): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.currentEpoch = object.currentEpoch ?? 0n;
    message.currentThreshold = object.currentThreshold ?? new Uint8Array(0);
    message.ownerKeys = object.ownerKeys?.map((e) => OwnerVRFKey.fromPartial(e)) || [];
    message.lastSubmitEpochs = object.lastSubmitEpochs?.map((e) => LastSubmitEpoch.fromPartial(e)) || [];
    message.epochs = object.epochs?.map((e) => EpochInfo.fromPartial(e)) || [];
    message.licenseInfos = object.licenseInfos?.map((e) => EpochLicenseInfo.fromPartial(e)) || [];
    message.epochWinners = object.epochWinners?.map((e) => EpochWinnersInfo.fromPartial(e)) || [];
    message.randaoMix = object.randaoMix ?? new Uint8Array(0);
    message.lastSettledEpoch = object.lastSettledEpoch ?? 0n;
    message.operators = object.operators?.map((e) => OperatorInfo.fromPartial(e)) || [];
    message.miningDelegations = object.miningDelegations?.map((e) => MiningDelegation.fromPartial(e)) || [];
    message.delegationQueue = object.delegationQueue?.map((e) => MiningDelegation.fromPartial(e)) || [];
    message.epochStartTime = object.epochStartTime ?? 0n;
    message.payoutQueue = object.payoutQueue?.map((e) => PayoutQueueItem.fromPartial(e)) || [];
    message.rateLimits = object.rateLimits?.map((e) => RateLimitEntry.fromPartial(e)) || [];
    message.lastDelegationEpochs = object.lastDelegationEpochs?.map((e) => LastDelegationEpochEntry.fromPartial(e)) ||
      [];
    message.signerRateLimits = object.signerRateLimits?.map((e) => SignerRateLimitEntry.fromPartial(e)) || [];
    message.carryoverEmission = (object.carryoverEmission !== undefined && object.carryoverEmission !== null)
      ? Coin.fromPartial(object.carryoverEmission)
      : undefined;
    message.allTimeCredits = object.allTimeCredits?.map((e) => AllTimeCreditsEntry.fromPartial(e)) || [];
    message.allTimePayouts = object.allTimePayouts?.map((e) => AllTimePayoutsEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLastSubmitEpoch(): LastSubmitEpoch {
  return { licenseId: 0n, epoch: 0n };
}

export const LastSubmitEpoch: MessageFns<LastSubmitEpoch> = {
  encode(message: LastSubmitEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastSubmitEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastSubmitEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastSubmitEpoch {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
    };
  },

  toJSON(message: LastSubmitEpoch): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LastSubmitEpoch>, I>>(base?: I): LastSubmitEpoch {
    return LastSubmitEpoch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LastSubmitEpoch>, I>>(object: I): LastSubmitEpoch {
    const message = createBaseLastSubmitEpoch();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    return message;
  },
};

function createBaseEpochLicenseInfo(): EpochLicenseInfo {
  return { epoch: 0n, licenseId: 0n, info: undefined };
}

export const EpochLicenseInfo: MessageFns<EpochLicenseInfo> = {
  encode(message: EpochLicenseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.licenseId);
    }
    if (message.info !== undefined) {
      LicenseInfo.encode(message.info, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochLicenseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochLicenseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.info = LicenseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochLicenseInfo {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      info: isSet(object.info) ? LicenseInfo.fromJSON(object.info) : undefined,
    };
  },

  toJSON(message: EpochLicenseInfo): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.info !== undefined) {
      obj.info = LicenseInfo.toJSON(message.info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochLicenseInfo>, I>>(base?: I): EpochLicenseInfo {
    return EpochLicenseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochLicenseInfo>, I>>(object: I): EpochLicenseInfo {
    const message = createBaseEpochLicenseInfo();
    message.epoch = object.epoch ?? 0n;
    message.licenseId = object.licenseId ?? 0n;
    message.info = (object.info !== undefined && object.info !== null)
      ? LicenseInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseEpochWinnersInfo(): EpochWinnersInfo {
  return { epoch: 0n, winners: [] };
}

export const EpochWinnersInfo: MessageFns<EpochWinnersInfo> = {
  encode(message: EpochWinnersInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    for (const v of message.winners) {
      Winner.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochWinnersInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochWinnersInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.winners.push(Winner.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochWinnersInfo {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      winners: globalThis.Array.isArray(object?.winners) ? object.winners.map((e: any) => Winner.fromJSON(e)) : [],
    };
  },

  toJSON(message: EpochWinnersInfo): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.winners?.length) {
      obj.winners = message.winners.map((e) => Winner.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochWinnersInfo>, I>>(base?: I): EpochWinnersInfo {
    return EpochWinnersInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochWinnersInfo>, I>>(object: I): EpochWinnersInfo {
    const message = createBaseEpochWinnersInfo();
    message.epoch = object.epoch ?? 0n;
    message.winners = object.winners?.map((e) => Winner.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayoutQueueItem(): PayoutQueueItem {
  return { licenseId: 0n, epoch: 0n, recipient: "", amount: "" };
}

export const PayoutQueueItem: MessageFns<PayoutQueueItem> = {
  encode(message: PayoutQueueItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    if (message.recipient !== "") {
      writer.uint32(26).string(message.recipient);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayoutQueueItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayoutQueueItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayoutQueueItem {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: PayoutQueueItem): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayoutQueueItem>, I>>(base?: I): PayoutQueueItem {
    return PayoutQueueItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayoutQueueItem>, I>>(object: I): PayoutQueueItem {
    const message = createBasePayoutQueueItem();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    message.recipient = object.recipient ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseRateLimitEntry(): RateLimitEntry {
  return { epoch: 0n, licenseId: 0n, count: 0 };
}

export const RateLimitEntry: MessageFns<RateLimitEntry> = {
  encode(message: RateLimitEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.licenseId);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitEntry {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: RateLimitEntry): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitEntry>, I>>(base?: I): RateLimitEntry {
    return RateLimitEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitEntry>, I>>(object: I): RateLimitEntry {
    const message = createBaseRateLimitEntry();
    message.epoch = object.epoch ?? 0n;
    message.licenseId = object.licenseId ?? 0n;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseLastDelegationEpochEntry(): LastDelegationEpochEntry {
  return { licenseId: 0n, epoch: 0n };
}

export const LastDelegationEpochEntry: MessageFns<LastDelegationEpochEntry> = {
  encode(message: LastDelegationEpochEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastDelegationEpochEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastDelegationEpochEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastDelegationEpochEntry {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
    };
  },

  toJSON(message: LastDelegationEpochEntry): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LastDelegationEpochEntry>, I>>(base?: I): LastDelegationEpochEntry {
    return LastDelegationEpochEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LastDelegationEpochEntry>, I>>(object: I): LastDelegationEpochEntry {
    const message = createBaseLastDelegationEpochEntry();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    return message;
  },
};

function createBaseSignerRateLimitEntry(): SignerRateLimitEntry {
  return { epoch: 0n, signer: new Uint8Array(0), count: 0 };
}

export const SignerRateLimitEntry: MessageFns<SignerRateLimitEntry> = {
  encode(message: SignerRateLimitEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    if (message.signer.length !== 0) {
      writer.uint32(18).bytes(message.signer);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignerRateLimitEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignerRateLimitEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signer = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignerRateLimitEntry {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      signer: isSet(object.signer) ? bytesFromBase64(object.signer) : new Uint8Array(0),
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: SignerRateLimitEntry): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.signer.length !== 0) {
      obj.signer = base64FromBytes(message.signer);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignerRateLimitEntry>, I>>(base?: I): SignerRateLimitEntry {
    return SignerRateLimitEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignerRateLimitEntry>, I>>(object: I): SignerRateLimitEntry {
    const message = createBaseSignerRateLimitEntry();
    message.epoch = object.epoch ?? 0n;
    message.signer = object.signer ?? new Uint8Array(0);
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseAllTimeCreditsEntry(): AllTimeCreditsEntry {
  return { licenseId: 0n, credits: 0n };
}

export const AllTimeCreditsEntry: MessageFns<AllTimeCreditsEntry> = {
  encode(message: AllTimeCreditsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.credits !== 0n) {
      if (BigInt.asUintN(64, message.credits) !== message.credits) {
        throw new globalThis.Error("value provided for field message.credits of type uint64 too large");
      }
      writer.uint32(16).uint64(message.credits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllTimeCreditsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllTimeCreditsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.credits = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllTimeCreditsEntry {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      credits: isSet(object.credits) ? BigInt(object.credits) : 0n,
    };
  },

  toJSON(message: AllTimeCreditsEntry): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.credits !== 0n) {
      obj.credits = message.credits.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllTimeCreditsEntry>, I>>(base?: I): AllTimeCreditsEntry {
    return AllTimeCreditsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllTimeCreditsEntry>, I>>(object: I): AllTimeCreditsEntry {
    const message = createBaseAllTimeCreditsEntry();
    message.licenseId = object.licenseId ?? 0n;
    message.credits = object.credits ?? 0n;
    return message;
  },
};

function createBaseAllTimePayoutsEntry(): AllTimePayoutsEntry {
  return { licenseId: 0n, payout: "" };
}

export const AllTimePayoutsEntry: MessageFns<AllTimePayoutsEntry> = {
  encode(message: AllTimePayoutsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.payout !== "") {
      writer.uint32(18).string(message.payout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllTimePayoutsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllTimePayoutsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payout = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllTimePayoutsEntry {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      payout: isSet(object.payout) ? globalThis.String(object.payout) : "",
    };
  },

  toJSON(message: AllTimePayoutsEntry): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.payout !== "") {
      obj.payout = message.payout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllTimePayoutsEntry>, I>>(base?: I): AllTimePayoutsEntry {
    return AllTimePayoutsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllTimePayoutsEntry>, I>>(object: I): AllTimePayoutsEntry {
    const message = createBaseAllTimePayoutsEntry();
    message.licenseId = object.licenseId ?? 0n;
    message.payout = object.payout ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
