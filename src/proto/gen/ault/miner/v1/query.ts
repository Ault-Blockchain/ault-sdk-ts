// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/miner/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { EpochInfo, MiningDelegation, OperatorInfo, Params } from "./miner";

export const protobufPackage = "ault.miner.v1";

/** QueryEpochRequest is the request for Query/Epoch */
export interface QueryEpochRequest {
}

/** QueryEpochResponse is the response for Query/Epoch */
export interface QueryEpochResponse {
  /** epoch is the current epoch number */
  epoch: bigint;
  /** seed for current epoch (32 bytes) */
  seed: Uint8Array;
  /** threshold for winning (Q.128 fixed point as 32 bytes) */
  threshold: Uint8Array;
}

/** QueryLicenseMinerInfoRequest is the request for Query/LicenseMinerInfo */
export interface QueryLicenseMinerInfoRequest {
  /** license_id to query */
  licenseId: bigint;
}

/** QueryLicenseMinerInfoResponse is the response for Query/LicenseMinerInfo */
export interface QueryLicenseMinerInfoResponse {
  /** vrf_pubkey registered for this license */
  vrfPubkey: Uint8Array;
  /** last_submit_epoch is the last epoch this license submitted work */
  lastSubmitEpoch: bigint;
  /** eligible_now indicates if license can mine now */
  eligibleNow: boolean;
  /** quarantined_local indicates miner-local quarantine flag */
  quarantinedLocal: boolean;
  /** quarantined_source indicates quarantine per x/license */
  quarantinedSource: boolean;
  /** all_time_credits is the cumulative count of successful work submissions */
  allTimeCredits: bigint;
  /**
   * all_time_payouts is the cumulative amount paid out to this license (sdk.Int
   * string)
   */
  allTimePayouts: string;
}

/** QueryBeaconRequest is the request for Query/Beacon */
export interface QueryBeaconRequest {
  /** epoch to query */
  epoch: bigint;
}

/** QueryBeaconResponse is the response for Query/Beacon */
export interface QueryBeaconResponse {
  /** r is the beacon value R (32 bytes) */
  r: Uint8Array;
  /** finalized indicates if beacon is finalized */
  finalized: boolean;
}

/** QueryParamsRequest is the request for Query/Params */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is the response for Query/Params */
export interface QueryParamsResponse {
  /** params contains all module parameters */
  params: Params | undefined;
}

/** QueryEmissionInfoRequest is the request for Query/EmissionInfo */
export interface QueryEmissionInfoRequest {
}

/** QueryEmissionInfoResponse is the response for Query/EmissionInfo */
export interface QueryEmissionInfoResponse {
  /** current_year is the current emission year (1-10) */
  currentYear: number;
  /** annual_emission for the current year */
  annualEmission: string;
  /** monthly_emission for the current year */
  monthlyEmission: string;
  /** daily_emission for the current year */
  dailyEmission: string;
  /** cumulative_emitted since genesis (epoch-based calculation) */
  cumulativeEmitted: string;
  /**
   * epochs_until_next_year shows how many epochs remain in current emission
   * year
   */
  epochsUntilNextYear: bigint;
  /** current_epoch is the current epoch number */
  currentEpoch: bigint;
  /** epochs_per_year is the configured number of epochs per emission year */
  epochsPerYear: bigint;
}

/** QueryEmissionScheduleRequest is the request for Query/EmissionSchedule */
export interface QueryEmissionScheduleRequest {
}

/** YearEmission is an entry in the emission schedule */
export interface YearEmission {
  /** year number */
  year: number;
  /** annual_emission for this year */
  annualEmission: string;
  /** monthly_emission for this year */
  monthlyEmission: string;
  /** daily_emission for this year */
  dailyEmission: string;
}

/** QueryEmissionScheduleResponse is the response for Query/EmissionSchedule */
export interface QueryEmissionScheduleResponse {
  /** schedule contains per-year emission data */
  schedule: YearEmission[];
}

/** QueryEpochInfoRequest is the request for Query/EpochInfoByID */
export interface QueryEpochInfoRequest {
  /** epoch to query */
  epoch: bigint;
}

/** QueryEpochInfoResponse contains full epoch information */
export interface QueryEpochInfoResponse {
  /** info contains the epoch details */
  info: EpochInfo | undefined;
}

/** QueryEpochsRequest is the request for Query/Epochs */
export interface QueryEpochsRequest {
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryEpochsResponse is the response for Query/Epochs */
export interface QueryEpochsResponse {
  /** epochs contains the requested epoch information */
  epochs: EpochInfo[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryOwnerKeyRequest is the request for Query/OwnerKey */
export interface QueryOwnerKeyRequest {
  /** owner address to query */
  owner: string;
}

/** QueryOwnerKeyResponse is the response for Query/OwnerKey */
export interface QueryOwnerKeyResponse {
  /** vrf_pubkey registered for this owner (32 bytes) */
  vrfPubkey: Uint8Array;
  /** nonce for the owner key (for rotation) */
  nonce: bigint;
  /**
   * last_rotation_time when key was last set/rotated (Unix timestamp in
   * seconds)
   */
  lastRotationTime: bigint;
  /** registration_epoch when the key was first registered */
  registrationEpoch: bigint;
  /** valid_from_epoch when the key becomes valid for use */
  validFromEpoch: bigint;
  /** registration_chain_id where the key was registered */
  registrationChainId: string;
}

/** QueryOperatorInfoRequest is the request for Query/OperatorInfo */
export interface QueryOperatorInfoRequest {
  /** operator address to query */
  operator: string;
}

/** QueryOperatorInfoResponse is the response for Query/OperatorInfo */
export interface QueryOperatorInfoResponse {
  /** info contains the operator details */
  info: OperatorInfo | undefined;
}

/** QueryOperatorsRequest is the request for Query/Operators */
export interface QueryOperatorsRequest {
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryOperatorsResponse is the response for Query/Operators */
export interface QueryOperatorsResponse {
  /** operators contains registered operators */
  operators: OperatorInfo[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryLicenseDelegationRequest is the request for Query/LicenseDelegation */
export interface QueryLicenseDelegationRequest {
  /** license_id to query */
  licenseId: bigint;
}

/** QueryLicenseDelegationResponse is the response for Query/LicenseDelegation */
export interface QueryLicenseDelegationResponse {
  /** delegation contains the delegation info (empty if not delegated) */
  delegation:
    | MiningDelegation
    | undefined;
  /** is_delegated indicates if the license is currently delegated */
  isDelegated: boolean;
}

/** QueryDelegatedLicensesRequest is the request for Query/DelegatedLicenses */
export interface QueryDelegatedLicensesRequest {
  /** operator address to query */
  operator: string;
  /** pagination defines the pagination in the request */
  pagination: PageRequest | undefined;
}

/** QueryDelegatedLicensesResponse is the response for Query/DelegatedLicenses */
export interface QueryDelegatedLicensesResponse {
  /** license_ids contains licenses delegated to this operator */
  licenseIds: bigint[];
  /** pagination defines the pagination in the response */
  pagination: PageResponse | undefined;
}

/** QueryLicensePayoutsRequest is the request for Query/LicensePayouts */
export interface QueryLicensePayoutsRequest {
  /** license_id to query */
  licenseId: bigint;
  /** from_epoch is the start epoch (inclusive), 0 means from beginning */
  fromEpoch: bigint;
  /** to_epoch is the end epoch (inclusive), 0 means to current epoch */
  toEpoch: bigint;
}

/** QueryLicensePayoutsResponse is the response for Query/LicensePayouts */
export interface QueryLicensePayoutsResponse {
  /** total_payout is the sum of payouts in the epoch range */
  totalPayout: string;
  /** total_credits is the sum of credits in the epoch range */
  totalCredits: bigint;
}

function createBaseQueryEpochRequest(): QueryEpochRequest {
  return {};
}

export const QueryEpochRequest: MessageFns<QueryEpochRequest> = {
  encode(_: QueryEpochRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryEpochRequest {
    return {};
  },

  toJSON(_: QueryEpochRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochRequest>, I>>(base?: I): QueryEpochRequest {
    return QueryEpochRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochRequest>, I>>(_: I): QueryEpochRequest {
    const message = createBaseQueryEpochRequest();
    return message;
  },
};

function createBaseQueryEpochResponse(): QueryEpochResponse {
  return { epoch: 0n, seed: new Uint8Array(0), threshold: new Uint8Array(0) };
}

export const QueryEpochResponse: MessageFns<QueryEpochResponse> = {
  encode(message: QueryEpochResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    if (message.seed.length !== 0) {
      writer.uint32(18).bytes(message.seed);
    }
    if (message.threshold.length !== 0) {
      writer.uint32(26).bytes(message.threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seed = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.threshold = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochResponse {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      seed: isSet(object.seed) ? bytesFromBase64(object.seed) : new Uint8Array(0),
      threshold: isSet(object.threshold) ? bytesFromBase64(object.threshold) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryEpochResponse): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.seed.length !== 0) {
      obj.seed = base64FromBytes(message.seed);
    }
    if (message.threshold.length !== 0) {
      obj.threshold = base64FromBytes(message.threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochResponse>, I>>(base?: I): QueryEpochResponse {
    return QueryEpochResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochResponse>, I>>(object: I): QueryEpochResponse {
    const message = createBaseQueryEpochResponse();
    message.epoch = object.epoch ?? 0n;
    message.seed = object.seed ?? new Uint8Array(0);
    message.threshold = object.threshold ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryLicenseMinerInfoRequest(): QueryLicenseMinerInfoRequest {
  return { licenseId: 0n };
}

export const QueryLicenseMinerInfoRequest: MessageFns<QueryLicenseMinerInfoRequest> = {
  encode(message: QueryLicenseMinerInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseMinerInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseMinerInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseMinerInfoRequest {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
    };
  },

  toJSON(message: QueryLicenseMinerInfoRequest): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseMinerInfoRequest>, I>>(base?: I): QueryLicenseMinerInfoRequest {
    return QueryLicenseMinerInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseMinerInfoRequest>, I>>(object: I): QueryLicenseMinerInfoRequest {
    const message = createBaseQueryLicenseMinerInfoRequest();
    message.licenseId = object.licenseId ?? 0n;
    return message;
  },
};

function createBaseQueryLicenseMinerInfoResponse(): QueryLicenseMinerInfoResponse {
  return {
    vrfPubkey: new Uint8Array(0),
    lastSubmitEpoch: 0n,
    eligibleNow: false,
    quarantinedLocal: false,
    quarantinedSource: false,
    allTimeCredits: 0n,
    allTimePayouts: "",
  };
}

export const QueryLicenseMinerInfoResponse: MessageFns<QueryLicenseMinerInfoResponse> = {
  encode(message: QueryLicenseMinerInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vrfPubkey.length !== 0) {
      writer.uint32(10).bytes(message.vrfPubkey);
    }
    if (message.lastSubmitEpoch !== 0n) {
      if (BigInt.asUintN(64, message.lastSubmitEpoch) !== message.lastSubmitEpoch) {
        throw new globalThis.Error("value provided for field message.lastSubmitEpoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.lastSubmitEpoch);
    }
    if (message.eligibleNow !== false) {
      writer.uint32(24).bool(message.eligibleNow);
    }
    if (message.quarantinedLocal !== false) {
      writer.uint32(32).bool(message.quarantinedLocal);
    }
    if (message.quarantinedSource !== false) {
      writer.uint32(40).bool(message.quarantinedSource);
    }
    if (message.allTimeCredits !== 0n) {
      if (BigInt.asUintN(64, message.allTimeCredits) !== message.allTimeCredits) {
        throw new globalThis.Error("value provided for field message.allTimeCredits of type uint64 too large");
      }
      writer.uint32(48).uint64(message.allTimeCredits);
    }
    if (message.allTimePayouts !== "") {
      writer.uint32(58).string(message.allTimePayouts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseMinerInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseMinerInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vrfPubkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastSubmitEpoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eligibleNow = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quarantinedLocal = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quarantinedSource = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allTimeCredits = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allTimePayouts = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseMinerInfoResponse {
    return {
      vrfPubkey: isSet(object.vrfPubkey)
        ? bytesFromBase64(object.vrfPubkey)
        : isSet(object.vrf_pubkey)
        ? bytesFromBase64(object.vrf_pubkey)
        : new Uint8Array(0),
      lastSubmitEpoch: isSet(object.lastSubmitEpoch)
        ? BigInt(object.lastSubmitEpoch)
        : isSet(object.last_submit_epoch)
        ? BigInt(object.last_submit_epoch)
        : 0n,
      eligibleNow: isSet(object.eligibleNow)
        ? globalThis.Boolean(object.eligibleNow)
        : isSet(object.eligible_now)
        ? globalThis.Boolean(object.eligible_now)
        : false,
      quarantinedLocal: isSet(object.quarantinedLocal)
        ? globalThis.Boolean(object.quarantinedLocal)
        : isSet(object.quarantined_local)
        ? globalThis.Boolean(object.quarantined_local)
        : false,
      quarantinedSource: isSet(object.quarantinedSource)
        ? globalThis.Boolean(object.quarantinedSource)
        : isSet(object.quarantined_source)
        ? globalThis.Boolean(object.quarantined_source)
        : false,
      allTimeCredits: isSet(object.allTimeCredits)
        ? BigInt(object.allTimeCredits)
        : isSet(object.all_time_credits)
        ? BigInt(object.all_time_credits)
        : 0n,
      allTimePayouts: isSet(object.allTimePayouts)
        ? globalThis.String(object.allTimePayouts)
        : isSet(object.all_time_payouts)
        ? globalThis.String(object.all_time_payouts)
        : "",
    };
  },

  toJSON(message: QueryLicenseMinerInfoResponse): unknown {
    const obj: any = {};
    if (message.vrfPubkey.length !== 0) {
      obj.vrfPubkey = base64FromBytes(message.vrfPubkey);
    }
    if (message.lastSubmitEpoch !== 0n) {
      obj.lastSubmitEpoch = message.lastSubmitEpoch.toString();
    }
    if (message.eligibleNow !== false) {
      obj.eligibleNow = message.eligibleNow;
    }
    if (message.quarantinedLocal !== false) {
      obj.quarantinedLocal = message.quarantinedLocal;
    }
    if (message.quarantinedSource !== false) {
      obj.quarantinedSource = message.quarantinedSource;
    }
    if (message.allTimeCredits !== 0n) {
      obj.allTimeCredits = message.allTimeCredits.toString();
    }
    if (message.allTimePayouts !== "") {
      obj.allTimePayouts = message.allTimePayouts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseMinerInfoResponse>, I>>(base?: I): QueryLicenseMinerInfoResponse {
    return QueryLicenseMinerInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseMinerInfoResponse>, I>>(
    object: I,
  ): QueryLicenseMinerInfoResponse {
    const message = createBaseQueryLicenseMinerInfoResponse();
    message.vrfPubkey = object.vrfPubkey ?? new Uint8Array(0);
    message.lastSubmitEpoch = object.lastSubmitEpoch ?? 0n;
    message.eligibleNow = object.eligibleNow ?? false;
    message.quarantinedLocal = object.quarantinedLocal ?? false;
    message.quarantinedSource = object.quarantinedSource ?? false;
    message.allTimeCredits = object.allTimeCredits ?? 0n;
    message.allTimePayouts = object.allTimePayouts ?? "";
    return message;
  },
};

function createBaseQueryBeaconRequest(): QueryBeaconRequest {
  return { epoch: 0n };
}

export const QueryBeaconRequest: MessageFns<QueryBeaconRequest> = {
  encode(message: QueryBeaconRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBeaconRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBeaconRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBeaconRequest {
    return { epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n };
  },

  toJSON(message: QueryBeaconRequest): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBeaconRequest>, I>>(base?: I): QueryBeaconRequest {
    return QueryBeaconRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBeaconRequest>, I>>(object: I): QueryBeaconRequest {
    const message = createBaseQueryBeaconRequest();
    message.epoch = object.epoch ?? 0n;
    return message;
  },
};

function createBaseQueryBeaconResponse(): QueryBeaconResponse {
  return { r: new Uint8Array(0), finalized: false };
}

export const QueryBeaconResponse: MessageFns<QueryBeaconResponse> = {
  encode(message: QueryBeaconResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.r.length !== 0) {
      writer.uint32(10).bytes(message.r);
    }
    if (message.finalized !== false) {
      writer.uint32(16).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBeaconResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBeaconResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.r = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBeaconResponse {
    return {
      r: isSet(object.r) ? bytesFromBase64(object.r) : new Uint8Array(0),
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: QueryBeaconResponse): unknown {
    const obj: any = {};
    if (message.r.length !== 0) {
      obj.r = base64FromBytes(message.r);
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBeaconResponse>, I>>(base?: I): QueryBeaconResponse {
    return QueryBeaconResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBeaconResponse>, I>>(object: I): QueryBeaconResponse {
    const message = createBaseQueryBeaconResponse();
    message.r = object.r ?? new Uint8Array(0);
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryEmissionInfoRequest(): QueryEmissionInfoRequest {
  return {};
}

export const QueryEmissionInfoRequest: MessageFns<QueryEmissionInfoRequest> = {
  encode(_: QueryEmissionInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEmissionInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEmissionInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryEmissionInfoRequest {
    return {};
  },

  toJSON(_: QueryEmissionInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEmissionInfoRequest>, I>>(base?: I): QueryEmissionInfoRequest {
    return QueryEmissionInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEmissionInfoRequest>, I>>(_: I): QueryEmissionInfoRequest {
    const message = createBaseQueryEmissionInfoRequest();
    return message;
  },
};

function createBaseQueryEmissionInfoResponse(): QueryEmissionInfoResponse {
  return {
    currentYear: 0,
    annualEmission: "",
    monthlyEmission: "",
    dailyEmission: "",
    cumulativeEmitted: "",
    epochsUntilNextYear: 0n,
    currentEpoch: 0n,
    epochsPerYear: 0n,
  };
}

export const QueryEmissionInfoResponse: MessageFns<QueryEmissionInfoResponse> = {
  encode(message: QueryEmissionInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentYear !== 0) {
      writer.uint32(8).uint32(message.currentYear);
    }
    if (message.annualEmission !== "") {
      writer.uint32(18).string(message.annualEmission);
    }
    if (message.monthlyEmission !== "") {
      writer.uint32(26).string(message.monthlyEmission);
    }
    if (message.dailyEmission !== "") {
      writer.uint32(34).string(message.dailyEmission);
    }
    if (message.cumulativeEmitted !== "") {
      writer.uint32(42).string(message.cumulativeEmitted);
    }
    if (message.epochsUntilNextYear !== 0n) {
      if (BigInt.asUintN(64, message.epochsUntilNextYear) !== message.epochsUntilNextYear) {
        throw new globalThis.Error("value provided for field message.epochsUntilNextYear of type uint64 too large");
      }
      writer.uint32(48).uint64(message.epochsUntilNextYear);
    }
    if (message.currentEpoch !== 0n) {
      if (BigInt.asUintN(64, message.currentEpoch) !== message.currentEpoch) {
        throw new globalThis.Error("value provided for field message.currentEpoch of type uint64 too large");
      }
      writer.uint32(56).uint64(message.currentEpoch);
    }
    if (message.epochsPerYear !== 0n) {
      if (BigInt.asUintN(64, message.epochsPerYear) !== message.epochsPerYear) {
        throw new globalThis.Error("value provided for field message.epochsPerYear of type uint64 too large");
      }
      writer.uint32(64).uint64(message.epochsPerYear);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEmissionInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEmissionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentYear = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annualEmission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.monthlyEmission = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dailyEmission = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cumulativeEmitted = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.epochsUntilNextYear = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.currentEpoch = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.epochsPerYear = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEmissionInfoResponse {
    return {
      currentYear: isSet(object.currentYear)
        ? globalThis.Number(object.currentYear)
        : isSet(object.current_year)
        ? globalThis.Number(object.current_year)
        : 0,
      annualEmission: isSet(object.annualEmission)
        ? globalThis.String(object.annualEmission)
        : isSet(object.annual_emission)
        ? globalThis.String(object.annual_emission)
        : "",
      monthlyEmission: isSet(object.monthlyEmission)
        ? globalThis.String(object.monthlyEmission)
        : isSet(object.monthly_emission)
        ? globalThis.String(object.monthly_emission)
        : "",
      dailyEmission: isSet(object.dailyEmission)
        ? globalThis.String(object.dailyEmission)
        : isSet(object.daily_emission)
        ? globalThis.String(object.daily_emission)
        : "",
      cumulativeEmitted: isSet(object.cumulativeEmitted)
        ? globalThis.String(object.cumulativeEmitted)
        : isSet(object.cumulative_emitted)
        ? globalThis.String(object.cumulative_emitted)
        : "",
      epochsUntilNextYear: isSet(object.epochsUntilNextYear)
        ? BigInt(object.epochsUntilNextYear)
        : isSet(object.epochs_until_next_year)
        ? BigInt(object.epochs_until_next_year)
        : 0n,
      currentEpoch: isSet(object.currentEpoch)
        ? BigInt(object.currentEpoch)
        : isSet(object.current_epoch)
        ? BigInt(object.current_epoch)
        : 0n,
      epochsPerYear: isSet(object.epochsPerYear)
        ? BigInt(object.epochsPerYear)
        : isSet(object.epochs_per_year)
        ? BigInt(object.epochs_per_year)
        : 0n,
    };
  },

  toJSON(message: QueryEmissionInfoResponse): unknown {
    const obj: any = {};
    if (message.currentYear !== 0) {
      obj.currentYear = Math.round(message.currentYear);
    }
    if (message.annualEmission !== "") {
      obj.annualEmission = message.annualEmission;
    }
    if (message.monthlyEmission !== "") {
      obj.monthlyEmission = message.monthlyEmission;
    }
    if (message.dailyEmission !== "") {
      obj.dailyEmission = message.dailyEmission;
    }
    if (message.cumulativeEmitted !== "") {
      obj.cumulativeEmitted = message.cumulativeEmitted;
    }
    if (message.epochsUntilNextYear !== 0n) {
      obj.epochsUntilNextYear = message.epochsUntilNextYear.toString();
    }
    if (message.currentEpoch !== 0n) {
      obj.currentEpoch = message.currentEpoch.toString();
    }
    if (message.epochsPerYear !== 0n) {
      obj.epochsPerYear = message.epochsPerYear.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEmissionInfoResponse>, I>>(base?: I): QueryEmissionInfoResponse {
    return QueryEmissionInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEmissionInfoResponse>, I>>(object: I): QueryEmissionInfoResponse {
    const message = createBaseQueryEmissionInfoResponse();
    message.currentYear = object.currentYear ?? 0;
    message.annualEmission = object.annualEmission ?? "";
    message.monthlyEmission = object.monthlyEmission ?? "";
    message.dailyEmission = object.dailyEmission ?? "";
    message.cumulativeEmitted = object.cumulativeEmitted ?? "";
    message.epochsUntilNextYear = object.epochsUntilNextYear ?? 0n;
    message.currentEpoch = object.currentEpoch ?? 0n;
    message.epochsPerYear = object.epochsPerYear ?? 0n;
    return message;
  },
};

function createBaseQueryEmissionScheduleRequest(): QueryEmissionScheduleRequest {
  return {};
}

export const QueryEmissionScheduleRequest: MessageFns<QueryEmissionScheduleRequest> = {
  encode(_: QueryEmissionScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEmissionScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEmissionScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryEmissionScheduleRequest {
    return {};
  },

  toJSON(_: QueryEmissionScheduleRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEmissionScheduleRequest>, I>>(base?: I): QueryEmissionScheduleRequest {
    return QueryEmissionScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEmissionScheduleRequest>, I>>(_: I): QueryEmissionScheduleRequest {
    const message = createBaseQueryEmissionScheduleRequest();
    return message;
  },
};

function createBaseYearEmission(): YearEmission {
  return { year: 0, annualEmission: "", monthlyEmission: "", dailyEmission: "" };
}

export const YearEmission: MessageFns<YearEmission> = {
  encode(message: YearEmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.year !== 0) {
      writer.uint32(8).uint32(message.year);
    }
    if (message.annualEmission !== "") {
      writer.uint32(18).string(message.annualEmission);
    }
    if (message.monthlyEmission !== "") {
      writer.uint32(26).string(message.monthlyEmission);
    }
    if (message.dailyEmission !== "") {
      writer.uint32(34).string(message.dailyEmission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YearEmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYearEmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.year = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annualEmission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.monthlyEmission = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dailyEmission = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YearEmission {
    return {
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      annualEmission: isSet(object.annualEmission)
        ? globalThis.String(object.annualEmission)
        : isSet(object.annual_emission)
        ? globalThis.String(object.annual_emission)
        : "",
      monthlyEmission: isSet(object.monthlyEmission)
        ? globalThis.String(object.monthlyEmission)
        : isSet(object.monthly_emission)
        ? globalThis.String(object.monthly_emission)
        : "",
      dailyEmission: isSet(object.dailyEmission)
        ? globalThis.String(object.dailyEmission)
        : isSet(object.daily_emission)
        ? globalThis.String(object.daily_emission)
        : "",
    };
  },

  toJSON(message: YearEmission): unknown {
    const obj: any = {};
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.annualEmission !== "") {
      obj.annualEmission = message.annualEmission;
    }
    if (message.monthlyEmission !== "") {
      obj.monthlyEmission = message.monthlyEmission;
    }
    if (message.dailyEmission !== "") {
      obj.dailyEmission = message.dailyEmission;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YearEmission>, I>>(base?: I): YearEmission {
    return YearEmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YearEmission>, I>>(object: I): YearEmission {
    const message = createBaseYearEmission();
    message.year = object.year ?? 0;
    message.annualEmission = object.annualEmission ?? "";
    message.monthlyEmission = object.monthlyEmission ?? "";
    message.dailyEmission = object.dailyEmission ?? "";
    return message;
  },
};

function createBaseQueryEmissionScheduleResponse(): QueryEmissionScheduleResponse {
  return { schedule: [] };
}

export const QueryEmissionScheduleResponse: MessageFns<QueryEmissionScheduleResponse> = {
  encode(message: QueryEmissionScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedule) {
      YearEmission.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEmissionScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEmissionScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedule.push(YearEmission.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEmissionScheduleResponse {
    return {
      schedule: globalThis.Array.isArray(object?.schedule)
        ? object.schedule.map((e: any) => YearEmission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryEmissionScheduleResponse): unknown {
    const obj: any = {};
    if (message.schedule?.length) {
      obj.schedule = message.schedule.map((e) => YearEmission.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEmissionScheduleResponse>, I>>(base?: I): QueryEmissionScheduleResponse {
    return QueryEmissionScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEmissionScheduleResponse>, I>>(
    object: I,
  ): QueryEmissionScheduleResponse {
    const message = createBaseQueryEmissionScheduleResponse();
    message.schedule = object.schedule?.map((e) => YearEmission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryEpochInfoRequest(): QueryEpochInfoRequest {
  return { epoch: 0n };
}

export const QueryEpochInfoRequest: MessageFns<QueryEpochInfoRequest> = {
  encode(message: QueryEpochInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochInfoRequest {
    return { epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n };
  },

  toJSON(message: QueryEpochInfoRequest): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochInfoRequest>, I>>(base?: I): QueryEpochInfoRequest {
    return QueryEpochInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochInfoRequest>, I>>(object: I): QueryEpochInfoRequest {
    const message = createBaseQueryEpochInfoRequest();
    message.epoch = object.epoch ?? 0n;
    return message;
  },
};

function createBaseQueryEpochInfoResponse(): QueryEpochInfoResponse {
  return { info: undefined };
}

export const QueryEpochInfoResponse: MessageFns<QueryEpochInfoResponse> = {
  encode(message: QueryEpochInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      EpochInfo.encode(message.info, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = EpochInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochInfoResponse {
    return { info: isSet(object.info) ? EpochInfo.fromJSON(object.info) : undefined };
  },

  toJSON(message: QueryEpochInfoResponse): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = EpochInfo.toJSON(message.info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochInfoResponse>, I>>(base?: I): QueryEpochInfoResponse {
    return QueryEpochInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochInfoResponse>, I>>(object: I): QueryEpochInfoResponse {
    const message = createBaseQueryEpochInfoResponse();
    message.info = (object.info !== undefined && object.info !== null) ? EpochInfo.fromPartial(object.info) : undefined;
    return message;
  },
};

function createBaseQueryEpochsRequest(): QueryEpochsRequest {
  return { pagination: undefined };
}

export const QueryEpochsRequest: MessageFns<QueryEpochsRequest> = {
  encode(message: QueryEpochsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryEpochsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochsRequest>, I>>(base?: I): QueryEpochsRequest {
    return QueryEpochsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochsRequest>, I>>(object: I): QueryEpochsRequest {
    const message = createBaseQueryEpochsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryEpochsResponse(): QueryEpochsResponse {
  return { epochs: [], pagination: undefined };
}

export const QueryEpochsResponse: MessageFns<QueryEpochsResponse> = {
  encode(message: QueryEpochsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.epochs) {
      EpochInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEpochsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEpochsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.epochs.push(EpochInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEpochsResponse {
    return {
      epochs: globalThis.Array.isArray(object?.epochs) ? object.epochs.map((e: any) => EpochInfo.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryEpochsResponse): unknown {
    const obj: any = {};
    if (message.epochs?.length) {
      obj.epochs = message.epochs.map((e) => EpochInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEpochsResponse>, I>>(base?: I): QueryEpochsResponse {
    return QueryEpochsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEpochsResponse>, I>>(object: I): QueryEpochsResponse {
    const message = createBaseQueryEpochsResponse();
    message.epochs = object.epochs?.map((e) => EpochInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOwnerKeyRequest(): QueryOwnerKeyRequest {
  return { owner: "" };
}

export const QueryOwnerKeyRequest: MessageFns<QueryOwnerKeyRequest> = {
  encode(message: QueryOwnerKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerKeyRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: QueryOwnerKeyRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerKeyRequest>, I>>(base?: I): QueryOwnerKeyRequest {
    return QueryOwnerKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerKeyRequest>, I>>(object: I): QueryOwnerKeyRequest {
    const message = createBaseQueryOwnerKeyRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryOwnerKeyResponse(): QueryOwnerKeyResponse {
  return {
    vrfPubkey: new Uint8Array(0),
    nonce: 0n,
    lastRotationTime: 0n,
    registrationEpoch: 0n,
    validFromEpoch: 0n,
    registrationChainId: "",
  };
}

export const QueryOwnerKeyResponse: MessageFns<QueryOwnerKeyResponse> = {
  encode(message: QueryOwnerKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vrfPubkey.length !== 0) {
      writer.uint32(10).bytes(message.vrfPubkey);
    }
    if (message.nonce !== 0n) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.lastRotationTime !== 0n) {
      if (BigInt.asIntN(64, message.lastRotationTime) !== message.lastRotationTime) {
        throw new globalThis.Error("value provided for field message.lastRotationTime of type int64 too large");
      }
      writer.uint32(24).int64(message.lastRotationTime);
    }
    if (message.registrationEpoch !== 0n) {
      if (BigInt.asUintN(64, message.registrationEpoch) !== message.registrationEpoch) {
        throw new globalThis.Error("value provided for field message.registrationEpoch of type uint64 too large");
      }
      writer.uint32(32).uint64(message.registrationEpoch);
    }
    if (message.validFromEpoch !== 0n) {
      if (BigInt.asUintN(64, message.validFromEpoch) !== message.validFromEpoch) {
        throw new globalThis.Error("value provided for field message.validFromEpoch of type uint64 too large");
      }
      writer.uint32(40).uint64(message.validFromEpoch);
    }
    if (message.registrationChainId !== "") {
      writer.uint32(50).string(message.registrationChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vrfPubkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nonce = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastRotationTime = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.registrationEpoch = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validFromEpoch = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.registrationChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerKeyResponse {
    return {
      vrfPubkey: isSet(object.vrfPubkey)
        ? bytesFromBase64(object.vrfPubkey)
        : isSet(object.vrf_pubkey)
        ? bytesFromBase64(object.vrf_pubkey)
        : new Uint8Array(0),
      nonce: isSet(object.nonce) ? BigInt(object.nonce) : 0n,
      lastRotationTime: isSet(object.lastRotationTime)
        ? BigInt(object.lastRotationTime)
        : isSet(object.last_rotation_time)
        ? BigInt(object.last_rotation_time)
        : 0n,
      registrationEpoch: isSet(object.registrationEpoch)
        ? BigInt(object.registrationEpoch)
        : isSet(object.registration_epoch)
        ? BigInt(object.registration_epoch)
        : 0n,
      validFromEpoch: isSet(object.validFromEpoch)
        ? BigInt(object.validFromEpoch)
        : isSet(object.valid_from_epoch)
        ? BigInt(object.valid_from_epoch)
        : 0n,
      registrationChainId: isSet(object.registrationChainId)
        ? globalThis.String(object.registrationChainId)
        : isSet(object.registration_chain_id)
        ? globalThis.String(object.registration_chain_id)
        : "",
    };
  },

  toJSON(message: QueryOwnerKeyResponse): unknown {
    const obj: any = {};
    if (message.vrfPubkey.length !== 0) {
      obj.vrfPubkey = base64FromBytes(message.vrfPubkey);
    }
    if (message.nonce !== 0n) {
      obj.nonce = message.nonce.toString();
    }
    if (message.lastRotationTime !== 0n) {
      obj.lastRotationTime = message.lastRotationTime.toString();
    }
    if (message.registrationEpoch !== 0n) {
      obj.registrationEpoch = message.registrationEpoch.toString();
    }
    if (message.validFromEpoch !== 0n) {
      obj.validFromEpoch = message.validFromEpoch.toString();
    }
    if (message.registrationChainId !== "") {
      obj.registrationChainId = message.registrationChainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerKeyResponse>, I>>(base?: I): QueryOwnerKeyResponse {
    return QueryOwnerKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerKeyResponse>, I>>(object: I): QueryOwnerKeyResponse {
    const message = createBaseQueryOwnerKeyResponse();
    message.vrfPubkey = object.vrfPubkey ?? new Uint8Array(0);
    message.nonce = object.nonce ?? 0n;
    message.lastRotationTime = object.lastRotationTime ?? 0n;
    message.registrationEpoch = object.registrationEpoch ?? 0n;
    message.validFromEpoch = object.validFromEpoch ?? 0n;
    message.registrationChainId = object.registrationChainId ?? "";
    return message;
  },
};

function createBaseQueryOperatorInfoRequest(): QueryOperatorInfoRequest {
  return { operator: "" };
}

export const QueryOperatorInfoRequest: MessageFns<QueryOperatorInfoRequest> = {
  encode(message: QueryOperatorInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOperatorInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorInfoRequest {
    return { operator: isSet(object.operator) ? globalThis.String(object.operator) : "" };
  },

  toJSON(message: QueryOperatorInfoRequest): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorInfoRequest>, I>>(base?: I): QueryOperatorInfoRequest {
    return QueryOperatorInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorInfoRequest>, I>>(object: I): QueryOperatorInfoRequest {
    const message = createBaseQueryOperatorInfoRequest();
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseQueryOperatorInfoResponse(): QueryOperatorInfoResponse {
  return { info: undefined };
}

export const QueryOperatorInfoResponse: MessageFns<QueryOperatorInfoResponse> = {
  encode(message: QueryOperatorInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      OperatorInfo.encode(message.info, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOperatorInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = OperatorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorInfoResponse {
    return { info: isSet(object.info) ? OperatorInfo.fromJSON(object.info) : undefined };
  },

  toJSON(message: QueryOperatorInfoResponse): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = OperatorInfo.toJSON(message.info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorInfoResponse>, I>>(base?: I): QueryOperatorInfoResponse {
    return QueryOperatorInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorInfoResponse>, I>>(object: I): QueryOperatorInfoResponse {
    const message = createBaseQueryOperatorInfoResponse();
    message.info = (object.info !== undefined && object.info !== null)
      ? OperatorInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseQueryOperatorsRequest(): QueryOperatorsRequest {
  return { pagination: undefined };
}

export const QueryOperatorsRequest: MessageFns<QueryOperatorsRequest> = {
  encode(message: QueryOperatorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOperatorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryOperatorsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorsRequest>, I>>(base?: I): QueryOperatorsRequest {
    return QueryOperatorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorsRequest>, I>>(object: I): QueryOperatorsRequest {
    const message = createBaseQueryOperatorsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOperatorsResponse(): QueryOperatorsResponse {
  return { operators: [], pagination: undefined };
}

export const QueryOperatorsResponse: MessageFns<QueryOperatorsResponse> = {
  encode(message: QueryOperatorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operators) {
      OperatorInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOperatorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operators.push(OperatorInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorsResponse {
    return {
      operators: globalThis.Array.isArray(object?.operators)
        ? object.operators.map((e: any) => OperatorInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryOperatorsResponse): unknown {
    const obj: any = {};
    if (message.operators?.length) {
      obj.operators = message.operators.map((e) => OperatorInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorsResponse>, I>>(base?: I): QueryOperatorsResponse {
    return QueryOperatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorsResponse>, I>>(object: I): QueryOperatorsResponse {
    const message = createBaseQueryOperatorsResponse();
    message.operators = object.operators?.map((e) => OperatorInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryLicenseDelegationRequest(): QueryLicenseDelegationRequest {
  return { licenseId: 0n };
}

export const QueryLicenseDelegationRequest: MessageFns<QueryLicenseDelegationRequest> = {
  encode(message: QueryLicenseDelegationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseDelegationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseDelegationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseDelegationRequest {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
    };
  },

  toJSON(message: QueryLicenseDelegationRequest): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseDelegationRequest>, I>>(base?: I): QueryLicenseDelegationRequest {
    return QueryLicenseDelegationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseDelegationRequest>, I>>(
    object: I,
  ): QueryLicenseDelegationRequest {
    const message = createBaseQueryLicenseDelegationRequest();
    message.licenseId = object.licenseId ?? 0n;
    return message;
  },
};

function createBaseQueryLicenseDelegationResponse(): QueryLicenseDelegationResponse {
  return { delegation: undefined, isDelegated: false };
}

export const QueryLicenseDelegationResponse: MessageFns<QueryLicenseDelegationResponse> = {
  encode(message: QueryLicenseDelegationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegation !== undefined) {
      MiningDelegation.encode(message.delegation, writer.uint32(10).fork()).join();
    }
    if (message.isDelegated !== false) {
      writer.uint32(16).bool(message.isDelegated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicenseDelegationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicenseDelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegation = MiningDelegation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDelegated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicenseDelegationResponse {
    return {
      delegation: isSet(object.delegation) ? MiningDelegation.fromJSON(object.delegation) : undefined,
      isDelegated: isSet(object.isDelegated)
        ? globalThis.Boolean(object.isDelegated)
        : isSet(object.is_delegated)
        ? globalThis.Boolean(object.is_delegated)
        : false,
    };
  },

  toJSON(message: QueryLicenseDelegationResponse): unknown {
    const obj: any = {};
    if (message.delegation !== undefined) {
      obj.delegation = MiningDelegation.toJSON(message.delegation);
    }
    if (message.isDelegated !== false) {
      obj.isDelegated = message.isDelegated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicenseDelegationResponse>, I>>(base?: I): QueryLicenseDelegationResponse {
    return QueryLicenseDelegationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicenseDelegationResponse>, I>>(
    object: I,
  ): QueryLicenseDelegationResponse {
    const message = createBaseQueryLicenseDelegationResponse();
    message.delegation = (object.delegation !== undefined && object.delegation !== null)
      ? MiningDelegation.fromPartial(object.delegation)
      : undefined;
    message.isDelegated = object.isDelegated ?? false;
    return message;
  },
};

function createBaseQueryDelegatedLicensesRequest(): QueryDelegatedLicensesRequest {
  return { operator: "", pagination: undefined };
}

export const QueryDelegatedLicensesRequest: MessageFns<QueryDelegatedLicensesRequest> = {
  encode(message: QueryDelegatedLicensesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDelegatedLicensesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegatedLicensesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegatedLicensesRequest {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryDelegatedLicensesRequest): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegatedLicensesRequest>, I>>(base?: I): QueryDelegatedLicensesRequest {
    return QueryDelegatedLicensesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegatedLicensesRequest>, I>>(
    object: I,
  ): QueryDelegatedLicensesRequest {
    const message = createBaseQueryDelegatedLicensesRequest();
    message.operator = object.operator ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryDelegatedLicensesResponse(): QueryDelegatedLicensesResponse {
  return { licenseIds: [], pagination: undefined };
}

export const QueryDelegatedLicensesResponse: MessageFns<QueryDelegatedLicensesResponse> = {
  encode(message: QueryDelegatedLicensesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.licenseIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field licenseIds of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDelegatedLicensesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegatedLicensesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.licenseIds.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseIds.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegatedLicensesResponse {
    return {
      licenseIds: globalThis.Array.isArray(object?.licenseIds)
        ? object.licenseIds.map((e: any) => BigInt(e))
        : globalThis.Array.isArray(object?.license_ids)
        ? object.license_ids.map((e: any) => BigInt(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryDelegatedLicensesResponse): unknown {
    const obj: any = {};
    if (message.licenseIds?.length) {
      obj.licenseIds = message.licenseIds.map((e) => e.toString());
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegatedLicensesResponse>, I>>(base?: I): QueryDelegatedLicensesResponse {
    return QueryDelegatedLicensesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegatedLicensesResponse>, I>>(
    object: I,
  ): QueryDelegatedLicensesResponse {
    const message = createBaseQueryDelegatedLicensesResponse();
    message.licenseIds = object.licenseIds?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryLicensePayoutsRequest(): QueryLicensePayoutsRequest {
  return { licenseId: 0n, fromEpoch: 0n, toEpoch: 0n };
}

export const QueryLicensePayoutsRequest: MessageFns<QueryLicensePayoutsRequest> = {
  encode(message: QueryLicensePayoutsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.fromEpoch !== 0n) {
      if (BigInt.asUintN(64, message.fromEpoch) !== message.fromEpoch) {
        throw new globalThis.Error("value provided for field message.fromEpoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.fromEpoch);
    }
    if (message.toEpoch !== 0n) {
      if (BigInt.asUintN(64, message.toEpoch) !== message.toEpoch) {
        throw new globalThis.Error("value provided for field message.toEpoch of type uint64 too large");
      }
      writer.uint32(24).uint64(message.toEpoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensePayoutsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensePayoutsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromEpoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toEpoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensePayoutsRequest {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      fromEpoch: isSet(object.fromEpoch)
        ? BigInt(object.fromEpoch)
        : isSet(object.from_epoch)
        ? BigInt(object.from_epoch)
        : 0n,
      toEpoch: isSet(object.toEpoch) ? BigInt(object.toEpoch) : isSet(object.to_epoch) ? BigInt(object.to_epoch) : 0n,
    };
  },

  toJSON(message: QueryLicensePayoutsRequest): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.fromEpoch !== 0n) {
      obj.fromEpoch = message.fromEpoch.toString();
    }
    if (message.toEpoch !== 0n) {
      obj.toEpoch = message.toEpoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensePayoutsRequest>, I>>(base?: I): QueryLicensePayoutsRequest {
    return QueryLicensePayoutsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensePayoutsRequest>, I>>(object: I): QueryLicensePayoutsRequest {
    const message = createBaseQueryLicensePayoutsRequest();
    message.licenseId = object.licenseId ?? 0n;
    message.fromEpoch = object.fromEpoch ?? 0n;
    message.toEpoch = object.toEpoch ?? 0n;
    return message;
  },
};

function createBaseQueryLicensePayoutsResponse(): QueryLicensePayoutsResponse {
  return { totalPayout: "", totalCredits: 0n };
}

export const QueryLicensePayoutsResponse: MessageFns<QueryLicensePayoutsResponse> = {
  encode(message: QueryLicensePayoutsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalPayout !== "") {
      writer.uint32(10).string(message.totalPayout);
    }
    if (message.totalCredits !== 0n) {
      if (BigInt.asUintN(64, message.totalCredits) !== message.totalCredits) {
        throw new globalThis.Error("value provided for field message.totalCredits of type uint64 too large");
      }
      writer.uint32(16).uint64(message.totalCredits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLicensePayoutsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLicensePayoutsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.totalPayout = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCredits = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLicensePayoutsResponse {
    return {
      totalPayout: isSet(object.totalPayout)
        ? globalThis.String(object.totalPayout)
        : isSet(object.total_payout)
        ? globalThis.String(object.total_payout)
        : "",
      totalCredits: isSet(object.totalCredits)
        ? BigInt(object.totalCredits)
        : isSet(object.total_credits)
        ? BigInt(object.total_credits)
        : 0n,
    };
  },

  toJSON(message: QueryLicensePayoutsResponse): unknown {
    const obj: any = {};
    if (message.totalPayout !== "") {
      obj.totalPayout = message.totalPayout;
    }
    if (message.totalCredits !== 0n) {
      obj.totalCredits = message.totalCredits.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLicensePayoutsResponse>, I>>(base?: I): QueryLicensePayoutsResponse {
    return QueryLicensePayoutsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLicensePayoutsResponse>, I>>(object: I): QueryLicensePayoutsResponse {
    const message = createBaseQueryLicensePayoutsResponse();
    message.totalPayout = object.totalPayout ?? "";
    message.totalCredits = object.totalCredits ?? 0n;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
