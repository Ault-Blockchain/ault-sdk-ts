// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/miner/v1/miner.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "ault.miner.v1";

/** OwnerVRFKey represents a registered VRF key for an owner */
export interface OwnerVRFKey {
  /** owner is the owner address (raw 20 bytes) */
  owner: Uint8Array;
  /** pubkey is the VRF public key (32 bytes) */
  pubkey: Uint8Array;
  /** nonce for rotation tracking */
  nonce: bigint;
  /**
   * last_rotation_time is the timestamp when key was last rotated (Unix
   * timestamp in seconds)
   */
  lastRotationTime: bigint;
  /**
   * registration_epoch is the epoch when this key was registered
   * Used to enforce MinKeyAgeEpochs to prevent key-grinding attacks
   */
  registrationEpoch: bigint;
  /**
   * registration_chain_id is the chain ID when key was registered
   * Binds the key to a specific chain
   */
  registrationChainId: string;
}

/** Winner represents a winning submission for an epoch */
export interface Winner {
  /** license_id of the winner */
  licenseId: bigint;
  /** y is the VRF output (32 bytes) */
  y: Uint8Array;
}

/** EpochWinners is a wrapper for a list of winners for an epoch */
export interface EpochWinners {
  /** winners is the list of winners for this epoch */
  winners: Winner[];
}

/** EpochInfo contains information about an epoch */
export interface EpochInfo {
  /** epoch number */
  epoch: bigint;
  /** seed for this epoch (32 bytes) */
  seed: Uint8Array;
  /** threshold for winning (Q.128 fixed point as 32 bytes) */
  threshold: Uint8Array;
  /** beacon_r is the beacon value R for this epoch (32 bytes) */
  beaconR: Uint8Array;
  /** finalized indicates if beacon is finalized */
  finalized: boolean;
}

/** LicenseInfo tracks license stats for a specific epoch */
export interface LicenseInfo {
  /** credits earned */
  credits: bigint;
  /** payout is the total payout amount for this license in this epoch */
  payout: string;
  /** owner is the license owner at the time credits were earned */
  owner: string;
  /**
   * commission_recipient is the address to receive commission
   * Empty if not delegated
   */
  commissionRecipient: string;
  /**
   * commission_rate is the operator's commission rate at the time credits were
   * earned (0-100)
   */
  commissionRate: number;
  /**
   * operator is the operator address at the time credits were earned
   * Empty if not delegated
   */
  operator: string;
}

/** RewardQueueItem represents a reward to be paid out */
export interface RewardQueueItem {
  /** license_id to receive the reward */
  licenseId: bigint;
  /** epoch when the reward was earned */
  epoch: bigint;
  /** amount to be paid (in sdk.Int format) */
  amount: string;
}

/** OperatorInfo represents a registered mining operator */
export interface OperatorInfo {
  /** operator is the operator address */
  operator: string;
  /** commission_rate is the commission percentage (0-100) */
  commissionRate: number;
  /**
   * commission_recipient is the address to receive commission rewards
   * If empty, commission is sent to the operator address
   */
  commissionRecipient: string;
  /**
   * last_update_epoch is the epoch when operator info was last updated
   * Used to enforce per-epoch rate limiting on commission rate changes
   */
  lastUpdateEpoch: bigint;
}

/** MiningDelegation represents a delegation from a license to an operator */
export interface MiningDelegation {
  /** license_id that is delegated */
  licenseId: bigint;
  /** operator is the delegated operator address */
  operator: string;
}

/** Params defines the parameters for the miner module */
export interface Params {
  /** epoch_length_seconds is the duration of each epoch in seconds */
  epochLengthSeconds: bigint;
  /** target_winners_per_epoch is the target number of winners per epoch */
  targetWinnersPerEpoch: number;
  /** max_winners_per_epoch is the maximum winners allowed per epoch */
  maxWinnersPerEpoch: number;
  /**
   * submission_window_seconds is the window after epoch end for submissions (in
   * seconds)
   */
  submissionWindowSeconds: number;
  /** controller_alpha_q16 is the controller gain in Q.16 fixed point */
  controllerAlphaQ16: number;
  /** controller_window is the number of epochs to average for control */
  controllerWindow: number;
  /** threshold_min is the minimum threshold (256-bit as hex string) */
  thresholdMin: string;
  /** threshold_max is the maximum threshold (256-bit as hex string) */
  thresholdMax: string;
  /** beacon_window_epochs is the number of epochs to mix for beacon */
  beaconWindowEpochs: number;
  /** key_rotation_cooldown_seconds is the cooldown for key rotation (in seconds) */
  keyRotationCooldownSeconds: bigint;
  /** vrf_verify_gas charges this much gas in ante for VRF verification */
  vrfVerifyGas: number;
  /**
   * min_key_age_epochs is the minimum age in epochs a key must have before it
   * can be used This prevents key-grinding attacks where attackers generate
   * keys after seeing the epoch seed
   */
  minKeyAgeEpochs: number;
  /**
   * initial_emission_per_epoch is the initial emission amount per epoch
   * This is the starting emission rate that decays over time
   */
  initialEmissionPerEpoch: string;
  /** emission_decay_rate is the annual decay factor as basis points / 10^8 */
  emissionDecayRate: string;
  /** max_emission_years is the maximum number of emission years */
  maxEmissionYears: number;
  /**
   * max_payouts_per_block limits the number of payouts processed per block
   * for deterministic execution. Each payout (transfer + bookkeeping) is
   * atomic. Prevents unbounded work per block and double-payout bugs. Default:
   * 500, Range: 1-100000
   */
  maxPayoutsPerBlock: number;
  /**
   * max_epochs_per_block limits the number of epochs that can be advanced per
   * block to prevent excessive gas usage in epoch advancement Default: 100
   */
  maxEpochsPerBlock: bigint;
  /**
   * staking_reward_percentage is the percentage of emissions to send to the
   * staking reward pool via distribution module (0-100)
   * Default: 5 (5% to stakers, 95% to miners)
   * Example: 20 means 20% to stakers, 80% to miners
   */
  stakingRewardPercentage: number;
  /**
   * max_commission_rate is the maximum commission rate operators can set
   * (0-100) Default: 50 (50%)
   */
  maxCommissionRate: number;
  /**
   * max_commission_rate_increase_per_epoch is the maximum commission rate
   * increase allowed per epoch (0-100) Default: 5 (5%)
   * This protects delegators from sudden commission rate increases
   */
  maxCommissionRateIncreasePerEpoch: number;
  /**
   * free_mining_until_epoch specifies the epoch until which miners get free gas
   * for mining-related messages. Set to 0 to disable.
   */
  freeMiningUntilEpoch: bigint;
  /**
   * free_mining_max_gas_limit is the maximum gas allowed per transaction for
   * free mining. Prevents abuse even with free gas.
   */
  freeMiningMaxGasLimit: bigint;
  /**
   * miner_allowed_msgs is the list of message type URLs that miners (license
   * holders / operators) are allowed to execute with free gas
   */
  minerAllowedMsgs: string[];
  /**
   * max_free_tx_per_epoch limits the number of free mining transactions
   * a signer can submit per epoch. This encourages batch submissions
   * to reduce network transaction count.
   * Default: 10, Range: 1-1000
   */
  maxFreeTxPerEpoch: number;
}

function createBaseOwnerVRFKey(): OwnerVRFKey {
  return {
    owner: new Uint8Array(0),
    pubkey: new Uint8Array(0),
    nonce: 0n,
    lastRotationTime: 0n,
    registrationEpoch: 0n,
    registrationChainId: "",
  };
}

export const OwnerVRFKey: MessageFns<OwnerVRFKey> = {
  encode(message: OwnerVRFKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner.length !== 0) {
      writer.uint32(10).bytes(message.owner);
    }
    if (message.pubkey.length !== 0) {
      writer.uint32(18).bytes(message.pubkey);
    }
    if (message.nonce !== 0n) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.lastRotationTime !== 0n) {
      if (BigInt.asIntN(64, message.lastRotationTime) !== message.lastRotationTime) {
        throw new globalThis.Error("value provided for field message.lastRotationTime of type int64 too large");
      }
      writer.uint32(32).int64(message.lastRotationTime);
    }
    if (message.registrationEpoch !== 0n) {
      if (BigInt.asUintN(64, message.registrationEpoch) !== message.registrationEpoch) {
        throw new globalThis.Error("value provided for field message.registrationEpoch of type uint64 too large");
      }
      writer.uint32(40).uint64(message.registrationEpoch);
    }
    if (message.registrationChainId !== "") {
      writer.uint32(50).string(message.registrationChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OwnerVRFKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwnerVRFKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pubkey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastRotationTime = reader.int64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.registrationEpoch = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.registrationChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OwnerVRFKey {
    return {
      owner: isSet(object.owner) ? bytesFromBase64(object.owner) : new Uint8Array(0),
      pubkey: isSet(object.pubkey) ? bytesFromBase64(object.pubkey) : new Uint8Array(0),
      nonce: isSet(object.nonce) ? BigInt(object.nonce) : 0n,
      lastRotationTime: isSet(object.lastRotationTime)
        ? BigInt(object.lastRotationTime)
        : isSet(object.last_rotation_time)
        ? BigInt(object.last_rotation_time)
        : 0n,
      registrationEpoch: isSet(object.registrationEpoch)
        ? BigInt(object.registrationEpoch)
        : isSet(object.registration_epoch)
        ? BigInt(object.registration_epoch)
        : 0n,
      registrationChainId: isSet(object.registrationChainId)
        ? globalThis.String(object.registrationChainId)
        : isSet(object.registration_chain_id)
        ? globalThis.String(object.registration_chain_id)
        : "",
    };
  },

  toJSON(message: OwnerVRFKey): unknown {
    const obj: any = {};
    if (message.owner.length !== 0) {
      obj.owner = base64FromBytes(message.owner);
    }
    if (message.pubkey.length !== 0) {
      obj.pubkey = base64FromBytes(message.pubkey);
    }
    if (message.nonce !== 0n) {
      obj.nonce = message.nonce.toString();
    }
    if (message.lastRotationTime !== 0n) {
      obj.lastRotationTime = message.lastRotationTime.toString();
    }
    if (message.registrationEpoch !== 0n) {
      obj.registrationEpoch = message.registrationEpoch.toString();
    }
    if (message.registrationChainId !== "") {
      obj.registrationChainId = message.registrationChainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OwnerVRFKey>, I>>(base?: I): OwnerVRFKey {
    return OwnerVRFKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OwnerVRFKey>, I>>(object: I): OwnerVRFKey {
    const message = createBaseOwnerVRFKey();
    message.owner = object.owner ?? new Uint8Array(0);
    message.pubkey = object.pubkey ?? new Uint8Array(0);
    message.nonce = object.nonce ?? 0n;
    message.lastRotationTime = object.lastRotationTime ?? 0n;
    message.registrationEpoch = object.registrationEpoch ?? 0n;
    message.registrationChainId = object.registrationChainId ?? "";
    return message;
  },
};

function createBaseWinner(): Winner {
  return { licenseId: 0n, y: new Uint8Array(0) };
}

export const Winner: MessageFns<Winner> = {
  encode(message: Winner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.y.length !== 0) {
      writer.uint32(18).bytes(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Winner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWinner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.y = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Winner {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      y: isSet(object.y) ? bytesFromBase64(object.y) : new Uint8Array(0),
    };
  },

  toJSON(message: Winner): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.y.length !== 0) {
      obj.y = base64FromBytes(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Winner>, I>>(base?: I): Winner {
    return Winner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Winner>, I>>(object: I): Winner {
    const message = createBaseWinner();
    message.licenseId = object.licenseId ?? 0n;
    message.y = object.y ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEpochWinners(): EpochWinners {
  return { winners: [] };
}

export const EpochWinners: MessageFns<EpochWinners> = {
  encode(message: EpochWinners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.winners) {
      Winner.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochWinners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochWinners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.winners.push(Winner.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochWinners {
    return {
      winners: globalThis.Array.isArray(object?.winners) ? object.winners.map((e: any) => Winner.fromJSON(e)) : [],
    };
  },

  toJSON(message: EpochWinners): unknown {
    const obj: any = {};
    if (message.winners?.length) {
      obj.winners = message.winners.map((e) => Winner.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochWinners>, I>>(base?: I): EpochWinners {
    return EpochWinners.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochWinners>, I>>(object: I): EpochWinners {
    const message = createBaseEpochWinners();
    message.winners = object.winners?.map((e) => Winner.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEpochInfo(): EpochInfo {
  return {
    epoch: 0n,
    seed: new Uint8Array(0),
    threshold: new Uint8Array(0),
    beaconR: new Uint8Array(0),
    finalized: false,
  };
}

export const EpochInfo: MessageFns<EpochInfo> = {
  encode(message: EpochInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epoch);
    }
    if (message.seed.length !== 0) {
      writer.uint32(18).bytes(message.seed);
    }
    if (message.threshold.length !== 0) {
      writer.uint32(26).bytes(message.threshold);
    }
    if (message.beaconR.length !== 0) {
      writer.uint32(34).bytes(message.beaconR);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seed = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.threshold = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.beaconR = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochInfo {
    return {
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      seed: isSet(object.seed) ? bytesFromBase64(object.seed) : new Uint8Array(0),
      threshold: isSet(object.threshold) ? bytesFromBase64(object.threshold) : new Uint8Array(0),
      beaconR: isSet(object.beaconR)
        ? bytesFromBase64(object.beaconR)
        : isSet(object.beacon_r)
        ? bytesFromBase64(object.beacon_r)
        : new Uint8Array(0),
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: EpochInfo): unknown {
    const obj: any = {};
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.seed.length !== 0) {
      obj.seed = base64FromBytes(message.seed);
    }
    if (message.threshold.length !== 0) {
      obj.threshold = base64FromBytes(message.threshold);
    }
    if (message.beaconR.length !== 0) {
      obj.beaconR = base64FromBytes(message.beaconR);
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpochInfo>, I>>(base?: I): EpochInfo {
    return EpochInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpochInfo>, I>>(object: I): EpochInfo {
    const message = createBaseEpochInfo();
    message.epoch = object.epoch ?? 0n;
    message.seed = object.seed ?? new Uint8Array(0);
    message.threshold = object.threshold ?? new Uint8Array(0);
    message.beaconR = object.beaconR ?? new Uint8Array(0);
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseLicenseInfo(): LicenseInfo {
  return { credits: 0n, payout: "", owner: "", commissionRecipient: "", commissionRate: 0, operator: "" };
}

export const LicenseInfo: MessageFns<LicenseInfo> = {
  encode(message: LicenseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credits !== 0n) {
      if (BigInt.asUintN(64, message.credits) !== message.credits) {
        throw new globalThis.Error("value provided for field message.credits of type uint64 too large");
      }
      writer.uint32(8).uint64(message.credits);
    }
    if (message.payout !== "") {
      writer.uint32(18).string(message.payout);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.commissionRecipient !== "") {
      writer.uint32(34).string(message.commissionRecipient);
    }
    if (message.commissionRate !== 0) {
      writer.uint32(40).uint32(message.commissionRate);
    }
    if (message.operator !== "") {
      writer.uint32(50).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LicenseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicenseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.credits = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payout = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commissionRecipient = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.commissionRate = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LicenseInfo {
    return {
      credits: isSet(object.credits) ? BigInt(object.credits) : 0n,
      payout: isSet(object.payout) ? globalThis.String(object.payout) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      commissionRecipient: isSet(object.commissionRecipient)
        ? globalThis.String(object.commissionRecipient)
        : isSet(object.commission_recipient)
        ? globalThis.String(object.commission_recipient)
        : "",
      commissionRate: isSet(object.commissionRate)
        ? globalThis.Number(object.commissionRate)
        : isSet(object.commission_rate)
        ? globalThis.Number(object.commission_rate)
        : 0,
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: LicenseInfo): unknown {
    const obj: any = {};
    if (message.credits !== 0n) {
      obj.credits = message.credits.toString();
    }
    if (message.payout !== "") {
      obj.payout = message.payout;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.commissionRecipient !== "") {
      obj.commissionRecipient = message.commissionRecipient;
    }
    if (message.commissionRate !== 0) {
      obj.commissionRate = Math.round(message.commissionRate);
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LicenseInfo>, I>>(base?: I): LicenseInfo {
    return LicenseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LicenseInfo>, I>>(object: I): LicenseInfo {
    const message = createBaseLicenseInfo();
    message.credits = object.credits ?? 0n;
    message.payout = object.payout ?? "";
    message.owner = object.owner ?? "";
    message.commissionRecipient = object.commissionRecipient ?? "";
    message.commissionRate = object.commissionRate ?? 0;
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseRewardQueueItem(): RewardQueueItem {
  return { licenseId: 0n, epoch: 0n, amount: "" };
}

export const RewardQueueItem: MessageFns<RewardQueueItem> = {
  encode(message: RewardQueueItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardQueueItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardQueueItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardQueueItem {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: RewardQueueItem): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RewardQueueItem>, I>>(base?: I): RewardQueueItem {
    return RewardQueueItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RewardQueueItem>, I>>(object: I): RewardQueueItem {
    const message = createBaseRewardQueueItem();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseOperatorInfo(): OperatorInfo {
  return { operator: "", commissionRate: 0, commissionRecipient: "", lastUpdateEpoch: 0n };
}

export const OperatorInfo: MessageFns<OperatorInfo> = {
  encode(message: OperatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    if (message.commissionRate !== 0) {
      writer.uint32(16).uint32(message.commissionRate);
    }
    if (message.commissionRecipient !== "") {
      writer.uint32(26).string(message.commissionRecipient);
    }
    if (message.lastUpdateEpoch !== 0n) {
      if (BigInt.asUintN(64, message.lastUpdateEpoch) !== message.lastUpdateEpoch) {
        throw new globalThis.Error("value provided for field message.lastUpdateEpoch of type uint64 too large");
      }
      writer.uint32(32).uint64(message.lastUpdateEpoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.commissionRate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commissionRecipient = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastUpdateEpoch = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorInfo {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      commissionRate: isSet(object.commissionRate)
        ? globalThis.Number(object.commissionRate)
        : isSet(object.commission_rate)
        ? globalThis.Number(object.commission_rate)
        : 0,
      commissionRecipient: isSet(object.commissionRecipient)
        ? globalThis.String(object.commissionRecipient)
        : isSet(object.commission_recipient)
        ? globalThis.String(object.commission_recipient)
        : "",
      lastUpdateEpoch: isSet(object.lastUpdateEpoch)
        ? BigInt(object.lastUpdateEpoch)
        : isSet(object.last_update_epoch)
        ? BigInt(object.last_update_epoch)
        : 0n,
    };
  },

  toJSON(message: OperatorInfo): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.commissionRate !== 0) {
      obj.commissionRate = Math.round(message.commissionRate);
    }
    if (message.commissionRecipient !== "") {
      obj.commissionRecipient = message.commissionRecipient;
    }
    if (message.lastUpdateEpoch !== 0n) {
      obj.lastUpdateEpoch = message.lastUpdateEpoch.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperatorInfo>, I>>(base?: I): OperatorInfo {
    return OperatorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperatorInfo>, I>>(object: I): OperatorInfo {
    const message = createBaseOperatorInfo();
    message.operator = object.operator ?? "";
    message.commissionRate = object.commissionRate ?? 0;
    message.commissionRecipient = object.commissionRecipient ?? "";
    message.lastUpdateEpoch = object.lastUpdateEpoch ?? 0n;
    return message;
  },
};

function createBaseMiningDelegation(): MiningDelegation {
  return { licenseId: 0n, operator: "" };
}

export const MiningDelegation: MessageFns<MiningDelegation> = {
  encode(message: MiningDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.operator !== "") {
      writer.uint32(18).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MiningDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMiningDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MiningDelegation {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: MiningDelegation): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MiningDelegation>, I>>(base?: I): MiningDelegation {
    return MiningDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MiningDelegation>, I>>(object: I): MiningDelegation {
    const message = createBaseMiningDelegation();
    message.licenseId = object.licenseId ?? 0n;
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseParams(): Params {
  return {
    epochLengthSeconds: 0n,
    targetWinnersPerEpoch: 0,
    maxWinnersPerEpoch: 0,
    submissionWindowSeconds: 0,
    controllerAlphaQ16: 0,
    controllerWindow: 0,
    thresholdMin: "",
    thresholdMax: "",
    beaconWindowEpochs: 0,
    keyRotationCooldownSeconds: 0n,
    vrfVerifyGas: 0,
    minKeyAgeEpochs: 0,
    initialEmissionPerEpoch: "",
    emissionDecayRate: "",
    maxEmissionYears: 0,
    maxPayoutsPerBlock: 0,
    maxEpochsPerBlock: 0n,
    stakingRewardPercentage: 0,
    maxCommissionRate: 0,
    maxCommissionRateIncreasePerEpoch: 0,
    freeMiningUntilEpoch: 0n,
    freeMiningMaxGasLimit: 0n,
    minerAllowedMsgs: [],
    maxFreeTxPerEpoch: 0,
  };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochLengthSeconds !== 0n) {
      if (BigInt.asUintN(64, message.epochLengthSeconds) !== message.epochLengthSeconds) {
        throw new globalThis.Error("value provided for field message.epochLengthSeconds of type uint64 too large");
      }
      writer.uint32(8).uint64(message.epochLengthSeconds);
    }
    if (message.targetWinnersPerEpoch !== 0) {
      writer.uint32(16).uint32(message.targetWinnersPerEpoch);
    }
    if (message.maxWinnersPerEpoch !== 0) {
      writer.uint32(24).uint32(message.maxWinnersPerEpoch);
    }
    if (message.submissionWindowSeconds !== 0) {
      writer.uint32(32).uint32(message.submissionWindowSeconds);
    }
    if (message.controllerAlphaQ16 !== 0) {
      writer.uint32(40).uint32(message.controllerAlphaQ16);
    }
    if (message.controllerWindow !== 0) {
      writer.uint32(48).uint32(message.controllerWindow);
    }
    if (message.thresholdMin !== "") {
      writer.uint32(58).string(message.thresholdMin);
    }
    if (message.thresholdMax !== "") {
      writer.uint32(66).string(message.thresholdMax);
    }
    if (message.beaconWindowEpochs !== 0) {
      writer.uint32(72).uint32(message.beaconWindowEpochs);
    }
    if (message.keyRotationCooldownSeconds !== 0n) {
      if (BigInt.asUintN(64, message.keyRotationCooldownSeconds) !== message.keyRotationCooldownSeconds) {
        throw new globalThis.Error(
          "value provided for field message.keyRotationCooldownSeconds of type uint64 too large",
        );
      }
      writer.uint32(80).uint64(message.keyRotationCooldownSeconds);
    }
    if (message.vrfVerifyGas !== 0) {
      writer.uint32(88).uint32(message.vrfVerifyGas);
    }
    if (message.minKeyAgeEpochs !== 0) {
      writer.uint32(96).uint32(message.minKeyAgeEpochs);
    }
    if (message.initialEmissionPerEpoch !== "") {
      writer.uint32(106).string(message.initialEmissionPerEpoch);
    }
    if (message.emissionDecayRate !== "") {
      writer.uint32(114).string(message.emissionDecayRate);
    }
    if (message.maxEmissionYears !== 0) {
      writer.uint32(120).uint32(message.maxEmissionYears);
    }
    if (message.maxPayoutsPerBlock !== 0) {
      writer.uint32(128).uint32(message.maxPayoutsPerBlock);
    }
    if (message.maxEpochsPerBlock !== 0n) {
      if (BigInt.asUintN(64, message.maxEpochsPerBlock) !== message.maxEpochsPerBlock) {
        throw new globalThis.Error("value provided for field message.maxEpochsPerBlock of type uint64 too large");
      }
      writer.uint32(136).uint64(message.maxEpochsPerBlock);
    }
    if (message.stakingRewardPercentage !== 0) {
      writer.uint32(144).uint32(message.stakingRewardPercentage);
    }
    if (message.maxCommissionRate !== 0) {
      writer.uint32(152).uint32(message.maxCommissionRate);
    }
    if (message.maxCommissionRateIncreasePerEpoch !== 0) {
      writer.uint32(160).uint32(message.maxCommissionRateIncreasePerEpoch);
    }
    if (message.freeMiningUntilEpoch !== 0n) {
      if (BigInt.asUintN(64, message.freeMiningUntilEpoch) !== message.freeMiningUntilEpoch) {
        throw new globalThis.Error("value provided for field message.freeMiningUntilEpoch of type uint64 too large");
      }
      writer.uint32(168).uint64(message.freeMiningUntilEpoch);
    }
    if (message.freeMiningMaxGasLimit !== 0n) {
      if (BigInt.asUintN(64, message.freeMiningMaxGasLimit) !== message.freeMiningMaxGasLimit) {
        throw new globalThis.Error("value provided for field message.freeMiningMaxGasLimit of type uint64 too large");
      }
      writer.uint32(176).uint64(message.freeMiningMaxGasLimit);
    }
    for (const v of message.minerAllowedMsgs) {
      writer.uint32(186).string(v!);
    }
    if (message.maxFreeTxPerEpoch !== 0) {
      writer.uint32(192).uint32(message.maxFreeTxPerEpoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochLengthSeconds = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetWinnersPerEpoch = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxWinnersPerEpoch = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.submissionWindowSeconds = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.controllerAlphaQ16 = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.controllerWindow = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.thresholdMin = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.thresholdMax = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.beaconWindowEpochs = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.keyRotationCooldownSeconds = reader.uint64() as bigint;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.vrfVerifyGas = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.minKeyAgeEpochs = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.initialEmissionPerEpoch = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.emissionDecayRate = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.maxEmissionYears = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.maxPayoutsPerBlock = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.maxEpochsPerBlock = reader.uint64() as bigint;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.stakingRewardPercentage = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.maxCommissionRate = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.maxCommissionRateIncreasePerEpoch = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.freeMiningUntilEpoch = reader.uint64() as bigint;
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.freeMiningMaxGasLimit = reader.uint64() as bigint;
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.minerAllowedMsgs.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.maxFreeTxPerEpoch = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      epochLengthSeconds: isSet(object.epochLengthSeconds)
        ? BigInt(object.epochLengthSeconds)
        : isSet(object.epoch_length_seconds)
        ? BigInt(object.epoch_length_seconds)
        : 0n,
      targetWinnersPerEpoch: isSet(object.targetWinnersPerEpoch)
        ? globalThis.Number(object.targetWinnersPerEpoch)
        : isSet(object.target_winners_per_epoch)
        ? globalThis.Number(object.target_winners_per_epoch)
        : 0,
      maxWinnersPerEpoch: isSet(object.maxWinnersPerEpoch)
        ? globalThis.Number(object.maxWinnersPerEpoch)
        : isSet(object.max_winners_per_epoch)
        ? globalThis.Number(object.max_winners_per_epoch)
        : 0,
      submissionWindowSeconds: isSet(object.submissionWindowSeconds)
        ? globalThis.Number(object.submissionWindowSeconds)
        : isSet(object.submission_window_seconds)
        ? globalThis.Number(object.submission_window_seconds)
        : 0,
      controllerAlphaQ16: isSet(object.controllerAlphaQ16)
        ? globalThis.Number(object.controllerAlphaQ16)
        : isSet(object.controller_alpha_q16)
        ? globalThis.Number(object.controller_alpha_q16)
        : 0,
      controllerWindow: isSet(object.controllerWindow)
        ? globalThis.Number(object.controllerWindow)
        : isSet(object.controller_window)
        ? globalThis.Number(object.controller_window)
        : 0,
      thresholdMin: isSet(object.thresholdMin)
        ? globalThis.String(object.thresholdMin)
        : isSet(object.threshold_min)
        ? globalThis.String(object.threshold_min)
        : "",
      thresholdMax: isSet(object.thresholdMax)
        ? globalThis.String(object.thresholdMax)
        : isSet(object.threshold_max)
        ? globalThis.String(object.threshold_max)
        : "",
      beaconWindowEpochs: isSet(object.beaconWindowEpochs)
        ? globalThis.Number(object.beaconWindowEpochs)
        : isSet(object.beacon_window_epochs)
        ? globalThis.Number(object.beacon_window_epochs)
        : 0,
      keyRotationCooldownSeconds: isSet(object.keyRotationCooldownSeconds)
        ? BigInt(object.keyRotationCooldownSeconds)
        : isSet(object.key_rotation_cooldown_seconds)
        ? BigInt(object.key_rotation_cooldown_seconds)
        : 0n,
      vrfVerifyGas: isSet(object.vrfVerifyGas)
        ? globalThis.Number(object.vrfVerifyGas)
        : isSet(object.vrf_verify_gas)
        ? globalThis.Number(object.vrf_verify_gas)
        : 0,
      minKeyAgeEpochs: isSet(object.minKeyAgeEpochs)
        ? globalThis.Number(object.minKeyAgeEpochs)
        : isSet(object.min_key_age_epochs)
        ? globalThis.Number(object.min_key_age_epochs)
        : 0,
      initialEmissionPerEpoch: isSet(object.initialEmissionPerEpoch)
        ? globalThis.String(object.initialEmissionPerEpoch)
        : isSet(object.initial_emission_per_epoch)
        ? globalThis.String(object.initial_emission_per_epoch)
        : "",
      emissionDecayRate: isSet(object.emissionDecayRate)
        ? globalThis.String(object.emissionDecayRate)
        : isSet(object.emission_decay_rate)
        ? globalThis.String(object.emission_decay_rate)
        : "",
      maxEmissionYears: isSet(object.maxEmissionYears)
        ? globalThis.Number(object.maxEmissionYears)
        : isSet(object.max_emission_years)
        ? globalThis.Number(object.max_emission_years)
        : 0,
      maxPayoutsPerBlock: isSet(object.maxPayoutsPerBlock)
        ? globalThis.Number(object.maxPayoutsPerBlock)
        : isSet(object.max_payouts_per_block)
        ? globalThis.Number(object.max_payouts_per_block)
        : 0,
      maxEpochsPerBlock: isSet(object.maxEpochsPerBlock)
        ? BigInt(object.maxEpochsPerBlock)
        : isSet(object.max_epochs_per_block)
        ? BigInt(object.max_epochs_per_block)
        : 0n,
      stakingRewardPercentage: isSet(object.stakingRewardPercentage)
        ? globalThis.Number(object.stakingRewardPercentage)
        : isSet(object.staking_reward_percentage)
        ? globalThis.Number(object.staking_reward_percentage)
        : 0,
      maxCommissionRate: isSet(object.maxCommissionRate)
        ? globalThis.Number(object.maxCommissionRate)
        : isSet(object.max_commission_rate)
        ? globalThis.Number(object.max_commission_rate)
        : 0,
      maxCommissionRateIncreasePerEpoch: isSet(object.maxCommissionRateIncreasePerEpoch)
        ? globalThis.Number(object.maxCommissionRateIncreasePerEpoch)
        : isSet(object.max_commission_rate_increase_per_epoch)
        ? globalThis.Number(object.max_commission_rate_increase_per_epoch)
        : 0,
      freeMiningUntilEpoch: isSet(object.freeMiningUntilEpoch)
        ? BigInt(object.freeMiningUntilEpoch)
        : isSet(object.free_mining_until_epoch)
        ? BigInt(object.free_mining_until_epoch)
        : 0n,
      freeMiningMaxGasLimit: isSet(object.freeMiningMaxGasLimit)
        ? BigInt(object.freeMiningMaxGasLimit)
        : isSet(object.free_mining_max_gas_limit)
        ? BigInt(object.free_mining_max_gas_limit)
        : 0n,
      minerAllowedMsgs: globalThis.Array.isArray(object?.minerAllowedMsgs)
        ? object.minerAllowedMsgs.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.miner_allowed_msgs)
        ? object.miner_allowed_msgs.map((e: any) => globalThis.String(e))
        : [],
      maxFreeTxPerEpoch: isSet(object.maxFreeTxPerEpoch)
        ? globalThis.Number(object.maxFreeTxPerEpoch)
        : isSet(object.max_free_tx_per_epoch)
        ? globalThis.Number(object.max_free_tx_per_epoch)
        : 0,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.epochLengthSeconds !== 0n) {
      obj.epochLengthSeconds = message.epochLengthSeconds.toString();
    }
    if (message.targetWinnersPerEpoch !== 0) {
      obj.targetWinnersPerEpoch = Math.round(message.targetWinnersPerEpoch);
    }
    if (message.maxWinnersPerEpoch !== 0) {
      obj.maxWinnersPerEpoch = Math.round(message.maxWinnersPerEpoch);
    }
    if (message.submissionWindowSeconds !== 0) {
      obj.submissionWindowSeconds = Math.round(message.submissionWindowSeconds);
    }
    if (message.controllerAlphaQ16 !== 0) {
      obj.controllerAlphaQ16 = Math.round(message.controllerAlphaQ16);
    }
    if (message.controllerWindow !== 0) {
      obj.controllerWindow = Math.round(message.controllerWindow);
    }
    if (message.thresholdMin !== "") {
      obj.thresholdMin = message.thresholdMin;
    }
    if (message.thresholdMax !== "") {
      obj.thresholdMax = message.thresholdMax;
    }
    if (message.beaconWindowEpochs !== 0) {
      obj.beaconWindowEpochs = Math.round(message.beaconWindowEpochs);
    }
    if (message.keyRotationCooldownSeconds !== 0n) {
      obj.keyRotationCooldownSeconds = message.keyRotationCooldownSeconds.toString();
    }
    if (message.vrfVerifyGas !== 0) {
      obj.vrfVerifyGas = Math.round(message.vrfVerifyGas);
    }
    if (message.minKeyAgeEpochs !== 0) {
      obj.minKeyAgeEpochs = Math.round(message.minKeyAgeEpochs);
    }
    if (message.initialEmissionPerEpoch !== "") {
      obj.initialEmissionPerEpoch = message.initialEmissionPerEpoch;
    }
    if (message.emissionDecayRate !== "") {
      obj.emissionDecayRate = message.emissionDecayRate;
    }
    if (message.maxEmissionYears !== 0) {
      obj.maxEmissionYears = Math.round(message.maxEmissionYears);
    }
    if (message.maxPayoutsPerBlock !== 0) {
      obj.maxPayoutsPerBlock = Math.round(message.maxPayoutsPerBlock);
    }
    if (message.maxEpochsPerBlock !== 0n) {
      obj.maxEpochsPerBlock = message.maxEpochsPerBlock.toString();
    }
    if (message.stakingRewardPercentage !== 0) {
      obj.stakingRewardPercentage = Math.round(message.stakingRewardPercentage);
    }
    if (message.maxCommissionRate !== 0) {
      obj.maxCommissionRate = Math.round(message.maxCommissionRate);
    }
    if (message.maxCommissionRateIncreasePerEpoch !== 0) {
      obj.maxCommissionRateIncreasePerEpoch = Math.round(message.maxCommissionRateIncreasePerEpoch);
    }
    if (message.freeMiningUntilEpoch !== 0n) {
      obj.freeMiningUntilEpoch = message.freeMiningUntilEpoch.toString();
    }
    if (message.freeMiningMaxGasLimit !== 0n) {
      obj.freeMiningMaxGasLimit = message.freeMiningMaxGasLimit.toString();
    }
    if (message.minerAllowedMsgs?.length) {
      obj.minerAllowedMsgs = message.minerAllowedMsgs;
    }
    if (message.maxFreeTxPerEpoch !== 0) {
      obj.maxFreeTxPerEpoch = Math.round(message.maxFreeTxPerEpoch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.epochLengthSeconds = object.epochLengthSeconds ?? 0n;
    message.targetWinnersPerEpoch = object.targetWinnersPerEpoch ?? 0;
    message.maxWinnersPerEpoch = object.maxWinnersPerEpoch ?? 0;
    message.submissionWindowSeconds = object.submissionWindowSeconds ?? 0;
    message.controllerAlphaQ16 = object.controllerAlphaQ16 ?? 0;
    message.controllerWindow = object.controllerWindow ?? 0;
    message.thresholdMin = object.thresholdMin ?? "";
    message.thresholdMax = object.thresholdMax ?? "";
    message.beaconWindowEpochs = object.beaconWindowEpochs ?? 0;
    message.keyRotationCooldownSeconds = object.keyRotationCooldownSeconds ?? 0n;
    message.vrfVerifyGas = object.vrfVerifyGas ?? 0;
    message.minKeyAgeEpochs = object.minKeyAgeEpochs ?? 0;
    message.initialEmissionPerEpoch = object.initialEmissionPerEpoch ?? "";
    message.emissionDecayRate = object.emissionDecayRate ?? "";
    message.maxEmissionYears = object.maxEmissionYears ?? 0;
    message.maxPayoutsPerBlock = object.maxPayoutsPerBlock ?? 0;
    message.maxEpochsPerBlock = object.maxEpochsPerBlock ?? 0n;
    message.stakingRewardPercentage = object.stakingRewardPercentage ?? 0;
    message.maxCommissionRate = object.maxCommissionRate ?? 0;
    message.maxCommissionRateIncreasePerEpoch = object.maxCommissionRateIncreasePerEpoch ?? 0;
    message.freeMiningUntilEpoch = object.freeMiningUntilEpoch ?? 0n;
    message.freeMiningMaxGasLimit = object.freeMiningMaxGasLimit ?? 0n;
    message.minerAllowedMsgs = object.minerAllowedMsgs?.map((e) => e) || [];
    message.maxFreeTxPerEpoch = object.maxFreeTxPerEpoch ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
