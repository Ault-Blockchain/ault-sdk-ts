// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: ault/miner/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./miner";

export const protobufPackage = "ault.miner.v1";

/** MsgSetOwnerVrfKey sets or rotates the VRF key for an owner */
export interface MsgSetOwnerVrfKey {
  /** vrf_pubkey is the 32-byte VRF public key */
  vrfPubkey: Uint8Array;
  /** possession_proof is signature by owner over POP_OWNER_KEY message */
  possessionProof: Uint8Array;
  /** nonce must match the current ownerKeyNonce[owner] */
  nonce: bigint;
  /** owner is the bech32 address setting the key */
  owner: string;
}

/** MsgSetOwnerVrfKeyResponse is the response for MsgSetOwnerVrfKey */
export interface MsgSetOwnerVrfKeyResponse {
}

/** MsgSubmitWork submits mining work for an epoch */
export interface MsgSubmitWork {
  /** license_id of the miner */
  licenseId: bigint;
  /** epoch number */
  epoch: bigint;
  /** y is the VRF output (32 bytes) */
  y: Uint8Array;
  /** proof is the VRF proof */
  proof: Uint8Array;
  /** nonce for micro-PoW */
  nonce: Uint8Array;
  /** submitter is the account submitting (can be different from owner) */
  submitter: string;
}

/** MsgSubmitWorkResponse is the response for MsgSubmitWork */
export interface MsgSubmitWorkResponse {
}

/** WorkSubmission represents a single work submission in a batch */
export interface WorkSubmission {
  /** license_id of the miner */
  licenseId: bigint;
  /** epoch number */
  epoch: bigint;
  /** y is the VRF output (32 bytes) */
  y: Uint8Array;
  /** proof is the VRF proof */
  proof: Uint8Array;
  /** nonce for micro-PoW */
  nonce: Uint8Array;
}

/**
 * MsgBatchSubmitWork submits multiple mining work entries for epochs (up to
 * 500)
 */
export interface MsgBatchSubmitWork {
  /** submissions is the list of work submissions (max 500) */
  submissions: WorkSubmission[];
  /** submitter is the account submitting (can be different from owner) */
  submitter: string;
}

/** MsgBatchSubmitWorkResponse is the response for MsgBatchSubmitWork */
export interface MsgBatchSubmitWorkResponse {
  /** results contains the result for each submission (success/failure) */
  results: boolean[];
  /** failed_indices contains the indices of failed submissions */
  failedIndices: number[];
}

/**
 * MsgUpdateParams defines a message to update the module parameters via
 * governance
 */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten)
   */
  authority: string;
  /** params are the new parameters */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse defines the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

/** MsgRegisterOperator registers a new mining operator */
export interface MsgRegisterOperator {
  /** operator is the address registering as an operator */
  operator: string;
  /** commission_rate is the commission percentage (0-100) */
  commissionRate: number;
  /**
   * commission_recipient is the address to receive commission rewards
   * (optional) If empty, commission is sent to the operator address
   */
  commissionRecipient: string;
}

/** MsgRegisterOperatorResponse is the response for MsgRegisterOperator */
export interface MsgRegisterOperatorResponse {
}

/** MsgUnregisterOperator removes an operator registration */
export interface MsgUnregisterOperator {
  /** operator is the address to unregister */
  operator: string;
}

/** MsgUnregisterOperatorResponse is the response for MsgUnregisterOperator */
export interface MsgUnregisterOperatorResponse {
}

/**
 * MsgUpdateOperatorInfo updates the operator's commission rate and commission
 * recipient
 */
export interface MsgUpdateOperatorInfo {
  /** operator is the operator address */
  operator: string;
  /** new_commission_rate is the new commission percentage (0-100) */
  newCommissionRate: number;
  /**
   * new_commission_recipient is the new address to receive commission rewards
   * If empty, commission will be sent to the operator address
   */
  newCommissionRecipient: string;
}

/** MsgUpdateOperatorInfoResponse is the response for MsgUpdateOperatorInfo */
export interface MsgUpdateOperatorInfoResponse {
}

/** MsgDelegateMining delegates licenses' mining rights to an operator */
export interface MsgDelegateMining {
  /** owner is the license owner address */
  owner: string;
  /** license_ids to delegate */
  licenseIds: bigint[];
  /** operator is the operator to delegate to */
  operator: string;
}

/** MsgDelegateMiningResponse is the response for MsgDelegateMining */
export interface MsgDelegateMiningResponse {
}

/** MsgRedelegateMining changes the operator for delegated licenses */
export interface MsgRedelegateMining {
  /** owner is the license owner address */
  owner: string;
  /** license_ids to redelegate */
  licenseIds: bigint[];
  /** new_operator is the new operator address */
  newOperator: string;
}

/** MsgRedelegateMiningResponse is the response for MsgRedelegateMining */
export interface MsgRedelegateMiningResponse {
}

/** MsgCancelMiningDelegation cancels licenses' mining delegation */
export interface MsgCancelMiningDelegation {
  /** owner is the license owner address */
  owner: string;
  /** license_ids to cancel delegation */
  licenseIds: bigint[];
}

/**
 * MsgCancelMiningDelegationResponse is the response for
 * MsgCancelMiningDelegation
 */
export interface MsgCancelMiningDelegationResponse {
}

function createBaseMsgSetOwnerVrfKey(): MsgSetOwnerVrfKey {
  return { vrfPubkey: new Uint8Array(0), possessionProof: new Uint8Array(0), nonce: 0n, owner: "" };
}

export const MsgSetOwnerVrfKey: MessageFns<MsgSetOwnerVrfKey> = {
  encode(message: MsgSetOwnerVrfKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vrfPubkey.length !== 0) {
      writer.uint32(10).bytes(message.vrfPubkey);
    }
    if (message.possessionProof.length !== 0) {
      writer.uint32(18).bytes(message.possessionProof);
    }
    if (message.nonce !== 0n) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.owner !== "") {
      writer.uint32(34).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOwnerVrfKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOwnerVrfKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vrfPubkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.possessionProof = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOwnerVrfKey {
    return {
      vrfPubkey: isSet(object.vrfPubkey)
        ? bytesFromBase64(object.vrfPubkey)
        : isSet(object.vrf_pubkey)
        ? bytesFromBase64(object.vrf_pubkey)
        : new Uint8Array(0),
      possessionProof: isSet(object.possessionProof)
        ? bytesFromBase64(object.possessionProof)
        : isSet(object.possession_proof)
        ? bytesFromBase64(object.possession_proof)
        : new Uint8Array(0),
      nonce: isSet(object.nonce) ? BigInt(object.nonce) : 0n,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: MsgSetOwnerVrfKey): unknown {
    const obj: any = {};
    if (message.vrfPubkey.length !== 0) {
      obj.vrfPubkey = base64FromBytes(message.vrfPubkey);
    }
    if (message.possessionProof.length !== 0) {
      obj.possessionProof = base64FromBytes(message.possessionProof);
    }
    if (message.nonce !== 0n) {
      obj.nonce = message.nonce.toString();
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOwnerVrfKey>, I>>(base?: I): MsgSetOwnerVrfKey {
    return MsgSetOwnerVrfKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOwnerVrfKey>, I>>(object: I): MsgSetOwnerVrfKey {
    const message = createBaseMsgSetOwnerVrfKey();
    message.vrfPubkey = object.vrfPubkey ?? new Uint8Array(0);
    message.possessionProof = object.possessionProof ?? new Uint8Array(0);
    message.nonce = object.nonce ?? 0n;
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseMsgSetOwnerVrfKeyResponse(): MsgSetOwnerVrfKeyResponse {
  return {};
}

export const MsgSetOwnerVrfKeyResponse: MessageFns<MsgSetOwnerVrfKeyResponse> = {
  encode(_: MsgSetOwnerVrfKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOwnerVrfKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOwnerVrfKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetOwnerVrfKeyResponse {
    return {};
  },

  toJSON(_: MsgSetOwnerVrfKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOwnerVrfKeyResponse>, I>>(base?: I): MsgSetOwnerVrfKeyResponse {
    return MsgSetOwnerVrfKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOwnerVrfKeyResponse>, I>>(_: I): MsgSetOwnerVrfKeyResponse {
    const message = createBaseMsgSetOwnerVrfKeyResponse();
    return message;
  },
};

function createBaseMsgSubmitWork(): MsgSubmitWork {
  return {
    licenseId: 0n,
    epoch: 0n,
    y: new Uint8Array(0),
    proof: new Uint8Array(0),
    nonce: new Uint8Array(0),
    submitter: "",
  };
}

export const MsgSubmitWork: MessageFns<MsgSubmitWork> = {
  encode(message: MsgSubmitWork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    if (message.y.length !== 0) {
      writer.uint32(26).bytes(message.y);
    }
    if (message.proof.length !== 0) {
      writer.uint32(34).bytes(message.proof);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.submitter !== "") {
      writer.uint32(50).string(message.submitter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitWork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitWork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.y = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitWork {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      y: isSet(object.y) ? bytesFromBase64(object.y) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
    };
  },

  toJSON(message: MsgSubmitWork): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.y.length !== 0) {
      obj.y = base64FromBytes(message.y);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitWork>, I>>(base?: I): MsgSubmitWork {
    return MsgSubmitWork.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitWork>, I>>(object: I): MsgSubmitWork {
    const message = createBaseMsgSubmitWork();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    message.y = object.y ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.submitter = object.submitter ?? "";
    return message;
  },
};

function createBaseMsgSubmitWorkResponse(): MsgSubmitWorkResponse {
  return {};
}

export const MsgSubmitWorkResponse: MessageFns<MsgSubmitWorkResponse> = {
  encode(_: MsgSubmitWorkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitWorkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitWorkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitWorkResponse {
    return {};
  },

  toJSON(_: MsgSubmitWorkResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitWorkResponse>, I>>(base?: I): MsgSubmitWorkResponse {
    return MsgSubmitWorkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitWorkResponse>, I>>(_: I): MsgSubmitWorkResponse {
    const message = createBaseMsgSubmitWorkResponse();
    return message;
  },
};

function createBaseWorkSubmission(): WorkSubmission {
  return { licenseId: 0n, epoch: 0n, y: new Uint8Array(0), proof: new Uint8Array(0), nonce: new Uint8Array(0) };
}

export const WorkSubmission: MessageFns<WorkSubmission> = {
  encode(message: WorkSubmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.licenseId !== 0n) {
      if (BigInt.asUintN(64, message.licenseId) !== message.licenseId) {
        throw new globalThis.Error("value provided for field message.licenseId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.licenseId);
    }
    if (message.epoch !== 0n) {
      if (BigInt.asUintN(64, message.epoch) !== message.epoch) {
        throw new globalThis.Error("value provided for field message.epoch of type uint64 too large");
      }
      writer.uint32(16).uint64(message.epoch);
    }
    if (message.y.length !== 0) {
      writer.uint32(26).bytes(message.y);
    }
    if (message.proof.length !== 0) {
      writer.uint32(34).bytes(message.proof);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkSubmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.licenseId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.y = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkSubmission {
    return {
      licenseId: isSet(object.licenseId)
        ? BigInt(object.licenseId)
        : isSet(object.license_id)
        ? BigInt(object.license_id)
        : 0n,
      epoch: isSet(object.epoch) ? BigInt(object.epoch) : 0n,
      y: isSet(object.y) ? bytesFromBase64(object.y) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
    };
  },

  toJSON(message: WorkSubmission): unknown {
    const obj: any = {};
    if (message.licenseId !== 0n) {
      obj.licenseId = message.licenseId.toString();
    }
    if (message.epoch !== 0n) {
      obj.epoch = message.epoch.toString();
    }
    if (message.y.length !== 0) {
      obj.y = base64FromBytes(message.y);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkSubmission>, I>>(base?: I): WorkSubmission {
    return WorkSubmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkSubmission>, I>>(object: I): WorkSubmission {
    const message = createBaseWorkSubmission();
    message.licenseId = object.licenseId ?? 0n;
    message.epoch = object.epoch ?? 0n;
    message.y = object.y ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    message.nonce = object.nonce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgBatchSubmitWork(): MsgBatchSubmitWork {
  return { submissions: [], submitter: "" };
}

export const MsgBatchSubmitWork: MessageFns<MsgBatchSubmitWork> = {
  encode(message: MsgBatchSubmitWork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.submissions) {
      WorkSubmission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.submitter !== "") {
      writer.uint32(18).string(message.submitter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchSubmitWork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchSubmitWork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissions.push(WorkSubmission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchSubmitWork {
    return {
      submissions: globalThis.Array.isArray(object?.submissions)
        ? object.submissions.map((e: any) => WorkSubmission.fromJSON(e))
        : [],
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
    };
  },

  toJSON(message: MsgBatchSubmitWork): unknown {
    const obj: any = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => WorkSubmission.toJSON(e));
    }
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchSubmitWork>, I>>(base?: I): MsgBatchSubmitWork {
    return MsgBatchSubmitWork.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchSubmitWork>, I>>(object: I): MsgBatchSubmitWork {
    const message = createBaseMsgBatchSubmitWork();
    message.submissions = object.submissions?.map((e) => WorkSubmission.fromPartial(e)) || [];
    message.submitter = object.submitter ?? "";
    return message;
  },
};

function createBaseMsgBatchSubmitWorkResponse(): MsgBatchSubmitWorkResponse {
  return { results: [], failedIndices: [] };
}

export const MsgBatchSubmitWorkResponse: MessageFns<MsgBatchSubmitWorkResponse> = {
  encode(message: MsgBatchSubmitWorkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.results) {
      writer.bool(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.failedIndices) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBatchSubmitWorkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchSubmitWorkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.results.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.results.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.failedIndices.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.failedIndices.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBatchSubmitWorkResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => globalThis.Boolean(e)) : [],
      failedIndices: globalThis.Array.isArray(object?.failedIndices)
        ? object.failedIndices.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.failed_indices)
        ? object.failed_indices.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: MsgBatchSubmitWorkResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results;
    }
    if (message.failedIndices?.length) {
      obj.failedIndices = message.failedIndices.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBatchSubmitWorkResponse>, I>>(base?: I): MsgBatchSubmitWorkResponse {
    return MsgBatchSubmitWorkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBatchSubmitWorkResponse>, I>>(object: I): MsgBatchSubmitWorkResponse {
    const message = createBaseMsgBatchSubmitWorkResponse();
    message.results = object.results?.map((e) => e) || [];
    message.failedIndices = object.failedIndices?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgRegisterOperator(): MsgRegisterOperator {
  return { operator: "", commissionRate: 0, commissionRecipient: "" };
}

export const MsgRegisterOperator: MessageFns<MsgRegisterOperator> = {
  encode(message: MsgRegisterOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    if (message.commissionRate !== 0) {
      writer.uint32(16).uint32(message.commissionRate);
    }
    if (message.commissionRecipient !== "") {
      writer.uint32(26).string(message.commissionRecipient);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.commissionRate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commissionRecipient = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterOperator {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      commissionRate: isSet(object.commissionRate)
        ? globalThis.Number(object.commissionRate)
        : isSet(object.commission_rate)
        ? globalThis.Number(object.commission_rate)
        : 0,
      commissionRecipient: isSet(object.commissionRecipient)
        ? globalThis.String(object.commissionRecipient)
        : isSet(object.commission_recipient)
        ? globalThis.String(object.commission_recipient)
        : "",
    };
  },

  toJSON(message: MsgRegisterOperator): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.commissionRate !== 0) {
      obj.commissionRate = Math.round(message.commissionRate);
    }
    if (message.commissionRecipient !== "") {
      obj.commissionRecipient = message.commissionRecipient;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterOperator>, I>>(base?: I): MsgRegisterOperator {
    return MsgRegisterOperator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterOperator>, I>>(object: I): MsgRegisterOperator {
    const message = createBaseMsgRegisterOperator();
    message.operator = object.operator ?? "";
    message.commissionRate = object.commissionRate ?? 0;
    message.commissionRecipient = object.commissionRecipient ?? "";
    return message;
  },
};

function createBaseMsgRegisterOperatorResponse(): MsgRegisterOperatorResponse {
  return {};
}

export const MsgRegisterOperatorResponse: MessageFns<MsgRegisterOperatorResponse> = {
  encode(_: MsgRegisterOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRegisterOperatorResponse {
    return {};
  },

  toJSON(_: MsgRegisterOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterOperatorResponse>, I>>(base?: I): MsgRegisterOperatorResponse {
    return MsgRegisterOperatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterOperatorResponse>, I>>(_: I): MsgRegisterOperatorResponse {
    const message = createBaseMsgRegisterOperatorResponse();
    return message;
  },
};

function createBaseMsgUnregisterOperator(): MsgUnregisterOperator {
  return { operator: "" };
}

export const MsgUnregisterOperator: MessageFns<MsgUnregisterOperator> = {
  encode(message: MsgUnregisterOperator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnregisterOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnregisterOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnregisterOperator {
    return { operator: isSet(object.operator) ? globalThis.String(object.operator) : "" };
  },

  toJSON(message: MsgUnregisterOperator): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnregisterOperator>, I>>(base?: I): MsgUnregisterOperator {
    return MsgUnregisterOperator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnregisterOperator>, I>>(object: I): MsgUnregisterOperator {
    const message = createBaseMsgUnregisterOperator();
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseMsgUnregisterOperatorResponse(): MsgUnregisterOperatorResponse {
  return {};
}

export const MsgUnregisterOperatorResponse: MessageFns<MsgUnregisterOperatorResponse> = {
  encode(_: MsgUnregisterOperatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnregisterOperatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnregisterOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUnregisterOperatorResponse {
    return {};
  },

  toJSON(_: MsgUnregisterOperatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnregisterOperatorResponse>, I>>(base?: I): MsgUnregisterOperatorResponse {
    return MsgUnregisterOperatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnregisterOperatorResponse>, I>>(_: I): MsgUnregisterOperatorResponse {
    const message = createBaseMsgUnregisterOperatorResponse();
    return message;
  },
};

function createBaseMsgUpdateOperatorInfo(): MsgUpdateOperatorInfo {
  return { operator: "", newCommissionRate: 0, newCommissionRecipient: "" };
}

export const MsgUpdateOperatorInfo: MessageFns<MsgUpdateOperatorInfo> = {
  encode(message: MsgUpdateOperatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    if (message.newCommissionRate !== 0) {
      writer.uint32(16).uint32(message.newCommissionRate);
    }
    if (message.newCommissionRecipient !== "") {
      writer.uint32(26).string(message.newCommissionRecipient);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOperatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOperatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newCommissionRate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newCommissionRecipient = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateOperatorInfo {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      newCommissionRate: isSet(object.newCommissionRate)
        ? globalThis.Number(object.newCommissionRate)
        : isSet(object.new_commission_rate)
        ? globalThis.Number(object.new_commission_rate)
        : 0,
      newCommissionRecipient: isSet(object.newCommissionRecipient)
        ? globalThis.String(object.newCommissionRecipient)
        : isSet(object.new_commission_recipient)
        ? globalThis.String(object.new_commission_recipient)
        : "",
    };
  },

  toJSON(message: MsgUpdateOperatorInfo): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.newCommissionRate !== 0) {
      obj.newCommissionRate = Math.round(message.newCommissionRate);
    }
    if (message.newCommissionRecipient !== "") {
      obj.newCommissionRecipient = message.newCommissionRecipient;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateOperatorInfo>, I>>(base?: I): MsgUpdateOperatorInfo {
    return MsgUpdateOperatorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateOperatorInfo>, I>>(object: I): MsgUpdateOperatorInfo {
    const message = createBaseMsgUpdateOperatorInfo();
    message.operator = object.operator ?? "";
    message.newCommissionRate = object.newCommissionRate ?? 0;
    message.newCommissionRecipient = object.newCommissionRecipient ?? "";
    return message;
  },
};

function createBaseMsgUpdateOperatorInfoResponse(): MsgUpdateOperatorInfoResponse {
  return {};
}

export const MsgUpdateOperatorInfoResponse: MessageFns<MsgUpdateOperatorInfoResponse> = {
  encode(_: MsgUpdateOperatorInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOperatorInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOperatorInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateOperatorInfoResponse {
    return {};
  },

  toJSON(_: MsgUpdateOperatorInfoResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateOperatorInfoResponse>, I>>(base?: I): MsgUpdateOperatorInfoResponse {
    return MsgUpdateOperatorInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateOperatorInfoResponse>, I>>(_: I): MsgUpdateOperatorInfoResponse {
    const message = createBaseMsgUpdateOperatorInfoResponse();
    return message;
  },
};

function createBaseMsgDelegateMining(): MsgDelegateMining {
  return { owner: "", licenseIds: [], operator: "" };
}

export const MsgDelegateMining: MessageFns<MsgDelegateMining> = {
  encode(message: MsgDelegateMining, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    writer.uint32(18).fork();
    for (const v of message.licenseIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field licenseIds of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDelegateMining {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDelegateMining();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.licenseIds.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseIds.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDelegateMining {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      licenseIds: globalThis.Array.isArray(object?.licenseIds)
        ? object.licenseIds.map((e: any) => BigInt(e))
        : globalThis.Array.isArray(object?.license_ids)
        ? object.license_ids.map((e: any) => BigInt(e))
        : [],
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: MsgDelegateMining): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.licenseIds?.length) {
      obj.licenseIds = message.licenseIds.map((e) => e.toString());
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDelegateMining>, I>>(base?: I): MsgDelegateMining {
    return MsgDelegateMining.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDelegateMining>, I>>(object: I): MsgDelegateMining {
    const message = createBaseMsgDelegateMining();
    message.owner = object.owner ?? "";
    message.licenseIds = object.licenseIds?.map((e) => e) || [];
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseMsgDelegateMiningResponse(): MsgDelegateMiningResponse {
  return {};
}

export const MsgDelegateMiningResponse: MessageFns<MsgDelegateMiningResponse> = {
  encode(_: MsgDelegateMiningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDelegateMiningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDelegateMiningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDelegateMiningResponse {
    return {};
  },

  toJSON(_: MsgDelegateMiningResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDelegateMiningResponse>, I>>(base?: I): MsgDelegateMiningResponse {
    return MsgDelegateMiningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDelegateMiningResponse>, I>>(_: I): MsgDelegateMiningResponse {
    const message = createBaseMsgDelegateMiningResponse();
    return message;
  },
};

function createBaseMsgRedelegateMining(): MsgRedelegateMining {
  return { owner: "", licenseIds: [], newOperator: "" };
}

export const MsgRedelegateMining: MessageFns<MsgRedelegateMining> = {
  encode(message: MsgRedelegateMining, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    writer.uint32(18).fork();
    for (const v of message.licenseIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field licenseIds of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    if (message.newOperator !== "") {
      writer.uint32(26).string(message.newOperator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRedelegateMining {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRedelegateMining();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.licenseIds.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseIds.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newOperator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRedelegateMining {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      licenseIds: globalThis.Array.isArray(object?.licenseIds)
        ? object.licenseIds.map((e: any) => BigInt(e))
        : globalThis.Array.isArray(object?.license_ids)
        ? object.license_ids.map((e: any) => BigInt(e))
        : [],
      newOperator: isSet(object.newOperator)
        ? globalThis.String(object.newOperator)
        : isSet(object.new_operator)
        ? globalThis.String(object.new_operator)
        : "",
    };
  },

  toJSON(message: MsgRedelegateMining): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.licenseIds?.length) {
      obj.licenseIds = message.licenseIds.map((e) => e.toString());
    }
    if (message.newOperator !== "") {
      obj.newOperator = message.newOperator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRedelegateMining>, I>>(base?: I): MsgRedelegateMining {
    return MsgRedelegateMining.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRedelegateMining>, I>>(object: I): MsgRedelegateMining {
    const message = createBaseMsgRedelegateMining();
    message.owner = object.owner ?? "";
    message.licenseIds = object.licenseIds?.map((e) => e) || [];
    message.newOperator = object.newOperator ?? "";
    return message;
  },
};

function createBaseMsgRedelegateMiningResponse(): MsgRedelegateMiningResponse {
  return {};
}

export const MsgRedelegateMiningResponse: MessageFns<MsgRedelegateMiningResponse> = {
  encode(_: MsgRedelegateMiningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRedelegateMiningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRedelegateMiningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRedelegateMiningResponse {
    return {};
  },

  toJSON(_: MsgRedelegateMiningResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRedelegateMiningResponse>, I>>(base?: I): MsgRedelegateMiningResponse {
    return MsgRedelegateMiningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRedelegateMiningResponse>, I>>(_: I): MsgRedelegateMiningResponse {
    const message = createBaseMsgRedelegateMiningResponse();
    return message;
  },
};

function createBaseMsgCancelMiningDelegation(): MsgCancelMiningDelegation {
  return { owner: "", licenseIds: [] };
}

export const MsgCancelMiningDelegation: MessageFns<MsgCancelMiningDelegation> = {
  encode(message: MsgCancelMiningDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    writer.uint32(18).fork();
    for (const v of message.licenseIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field licenseIds of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelMiningDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelMiningDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.licenseIds.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseIds.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelMiningDelegation {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      licenseIds: globalThis.Array.isArray(object?.licenseIds)
        ? object.licenseIds.map((e: any) => BigInt(e))
        : globalThis.Array.isArray(object?.license_ids)
        ? object.license_ids.map((e: any) => BigInt(e))
        : [],
    };
  },

  toJSON(message: MsgCancelMiningDelegation): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.licenseIds?.length) {
      obj.licenseIds = message.licenseIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelMiningDelegation>, I>>(base?: I): MsgCancelMiningDelegation {
    return MsgCancelMiningDelegation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelMiningDelegation>, I>>(object: I): MsgCancelMiningDelegation {
    const message = createBaseMsgCancelMiningDelegation();
    message.owner = object.owner ?? "";
    message.licenseIds = object.licenseIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgCancelMiningDelegationResponse(): MsgCancelMiningDelegationResponse {
  return {};
}

export const MsgCancelMiningDelegationResponse: MessageFns<MsgCancelMiningDelegationResponse> = {
  encode(_: MsgCancelMiningDelegationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelMiningDelegationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelMiningDelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelMiningDelegationResponse {
    return {};
  },

  toJSON(_: MsgCancelMiningDelegationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelMiningDelegationResponse>, I>>(
    base?: I,
  ): MsgCancelMiningDelegationResponse {
    return MsgCancelMiningDelegationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelMiningDelegationResponse>, I>>(
    _: I,
  ): MsgCancelMiningDelegationResponse {
    const message = createBaseMsgCancelMiningDelegationResponse();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
